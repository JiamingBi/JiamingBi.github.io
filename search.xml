<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>远程服务器之screen</title>
      <link href="2020/11036782.html"/>
      <url>2020/11036782.html</url>
      
        <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。GNU Screen可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。</p><p>在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。</p><p>在很多情况下，我们可能需要用服务器跑代码，但是由于代码工程巨大，跑起来需要花费几个小时的时间，而此时我们想关闭ssh远程连接，去做其他事情。就想让服务器能够在后台继续运行刚刚没有跑完的代码。所以，screen很好地满足了我们的需求。</p><h3 id="常用的screen参数"><a href="#常用的screen参数" class="headerlink" title="常用的screen参数"></a>常用的screen参数</h3><pre><code>screen -S yourname  新建一个叫yourname的sessionscreen -ls          列出当前所有的sessionscreen -r yourname  回到yourname这个sessionscreen -d yourname  远程detach某个sessionscreen -d -r yourname  结束当前session并回到yourname这个session</code></pre><h3 id="在Session下，使用ctrl-a-C-a"><a href="#在Session下，使用ctrl-a-C-a" class="headerlink" title="在Session下，使用ctrl+a(C-a)"></a>在Session下，使用ctrl+a(C-a)</h3><pre><code>C-a ?  显示所有键绑定信息C-a c  创建一个新的运行shell的窗口并切换到该窗口C-a n  Next，切换到下一个 window C-a p  Previous，切换到前一个 window C-a 0..9  切换到第 0..9 个 windowCtrl+a [Space]  由视窗0循序切换到视窗9C-a C-a  在两个最近使用的 window 间切换 C-a x  锁住当前的 window，需用用户密码解锁C-a d  detach，暂时离开当前session，将目前的 screen session (可能含有多个 windows) 丢到后台执行，并会回到还没进 screen 时的状态，此时在 screen session 里，每个 window 内运行的 process (无论是前台/后台)都在继续执行，即使 logout 也不影响。 C-a z  把当前session放到后台执行，用 shell 的 fg 命令则可回去。C-a w  显示所有窗口列表C-a t  time，显示当前时间，和系统的 load C-a k  kill window，强行关闭当前的 window</code></pre><h3 id="下面举例一个实际的操作"><a href="#下面举例一个实际的操作" class="headerlink" title="下面举例一个实际的操作"></a>下面举例一个实际的操作</h3><h4 id="1-首先使用ssh连接到远程服务器"><a href="#1-首先使用ssh连接到远程服务器" class="headerlink" title="1.首先使用ssh连接到远程服务器"></a>1.首先使用ssh连接到远程服务器</h4><p>​    ssh 用户名@ip地址</p><h4 id="2-创建一个新的screen"><a href="#2-创建一个新的screen" class="headerlink" title="2.创建一个新的screen"></a>2.创建一个新的screen</h4><p>​     screen -S test</p><h4 id="3-查看刚才创建的screen"><a href="#3-查看刚才创建的screen" class="headerlink" title="3.查看刚才创建的screen"></a>3.查看刚才创建的screen</h4><p>​    screen -ls</p><h4 id="4-到服务器中你文件的存放位置"><a href="#4-到服务器中你文件的存放位置" class="headerlink" title="4.到服务器中你文件的存放位置"></a>4.到服务器中你文件的存放位置</h4><p>​    cd 需要跑代码的文件路径</p><h4 id="5-运行代码"><a href="#5-运行代码" class="headerlink" title="5.运行代码"></a>5.运行代码</h4><p>​    screen 运行命令</p><h4 id="6-使用ctrl-a-d退出screen"><a href="#6-使用ctrl-a-d退出screen" class="headerlink" title="6.使用ctrl+a+d退出screen"></a>6.使用ctrl+a+d退出screen</h4><p>​    此时可以关闭窗口，这个时候代码已经在服务器后台运行了，就算掉线也没有关系。</p><h4 id="7-查看自己所有screen"><a href="#7-查看自己所有screen" class="headerlink" title="7.查看自己所有screen"></a>7.查看自己所有screen</h4><p>​    当你想重新看自己代码跑得怎么样的时候，可以重新登录服务器，使用</p><p>​    scree -ls查看自己的screen.</p><p>​    需要注意的是Detached是当前screen没有被打开，Attached表示当前screen正处在打开状态。</p><h4 id="8-重新打开screen"><a href="#8-重新打开screen" class="headerlink" title="8.重新打开screen"></a>8.重新打开screen</h4><p>​    screen -r screen进程号</p><p>​    但是，这里会发现使用screen恢复会话时出现There is no screen to be resumed matching错误</p><p>​    这个时候可以利用以下命令解决问题</p><p>​    screen -D -r screen号</p><p>​    或者</p><p>​    screen -d screen号</p><p>​    screen -r screen号</p><p>​    就可以完美看到自己代码跑的情况了。</p><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p><a href="https://blog.csdn.net/weixin_37968799/article/details/63754180">https://blog.csdn.net/weixin_37968799/article/details/63754180</a></p><p><a href="https://blog.csdn.net/fionaai/article/details/105174160">https://blog.csdn.net/fionaai/article/details/105174160</a></p><p>​    </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统目录结构和常见操作命令大全</title>
      <link href="2020/102314204.html"/>
      <url>2020/102314204.html</url>
      
        <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p>最近在学习Linux系统，由于对很多命令不太熟悉，所以在这里整理出来。无论是服务器还是实际的物理机器，都需要对linux命令比较熟悉。然后就上网查询、整理如下。</p><h1 id="Linux系统目录结构"><a href="#Linux系统目录结构" class="headerlink" title="Linux系统目录结构"></a>Linux系统目录结构</h1><p>对于每一个Linux学习者来说，了解Linux文件系统的目录结构，是学好Linux的至关重要的一步。深入了解linux文件目录结构的标准和每个目录的详细功能，下面我们就开始了解一下linux目录结构的相关知识首先先简单介绍一下linux下的目录结构，因为有一些命令会涉及到目录结构</p><p>树状目录结构：</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="img"></p><p>以下是对这些目录的解释：</p><ul><li><p><strong>/bin</strong>：<br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p></li><li><p><strong>/boot：</strong><br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li><li><p><strong>/dev ：</strong><br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p></li><li><p><strong>/etc：</strong><br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></li><li><p><strong>/home</strong>：<br>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p></li><li><p><strong>/lib</strong>：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p><strong>/lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></li><li><p><strong>/media</strong>：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p></li><li><p><strong>/mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</p></li><li><p><strong>/opt</strong>：<br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p></li><li><p><strong>/proc</strong>：<br>proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p><pre><code>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</code></pre></li><li><p><strong>/root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p><strong>/sbin</strong>：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p></li><li><p><strong>/selinux</strong>：<br> 这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p></li><li><p><strong>/srv</strong>：<br> 该目录存放一些服务启动之后需要提取的数据。</p></li><li><p><strong>/sys</strong>：</p><p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</p><p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p><p>该文件系统是内核设备树的一个直观反映。</p><p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p></li><li><p><strong>/tmp</strong>：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p></li><li><p><strong>/usr</strong>：<br> usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p></li><li><p><strong>/usr/bin：</strong><br>系统用户使用的应用程序。</p></li><li><p><strong>/usr/sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p></li><li><p><strong>/usr/src：</strong><br>内核源代码默认的放置目录。</p></li><li><p><strong>/var</strong>：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></li><li><p><strong>/run</strong>：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p></li></ul><p>在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。</p><p><strong>/etc</strong>： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。</p><p><strong>/bin, /sbin, /usr/bin, /usr/sbin</strong>: 这是系统预设的执行文件的放置目录，比如 ls 就是在 /bin/ls 目录下的。</p><p>值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给 root 使用的指令。</p><p><strong>/var</strong>： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里。</p><p><strong>一. 根目录 (/) 的意义与内容：</strong></p><p>根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的， 同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、 函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。 因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区， 因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。</p><p>因此FHS标准建议：根目录(/)所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。说白了，就是根目录和Windows的C盘一个样。</p><p><strong>二. /usr 的意义与内容：</strong></p><p>依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的(shareable, static)， 如果你知道如何透过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务器)，那么/usr确实可以分享给局域网络内的其他主机来使用喔。</p><p>/usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据啦。这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。</p><p>因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows 系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 一般来说，/usr的次目录建议有底下这些：</p><table><thead><tr><th>目录</th><th>应放置文件内容</th></tr></thead><tbody><tr><td>/usr/X11R6/</td><td>为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。</td></tr><tr><td>/usr/bin/</td><td>绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关)</td></tr><tr><td>/usr/include/</td><td>c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。</td></tr><tr><td>/usr/lib/</td><td>包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生</td></tr><tr><td>/usr/local/</td><td>统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录</td></tr><tr><td>/usr/sbin/</td><td>非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon)</td></tr><tr><td>/usr/share/</td><td>放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件/usr/share/doc：软件杂项的文件说明/usr/share/zoneinfo：与时区有关的时区文件</td></tr><tr><td>/usr/src/</td><td>一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。</td></tr></tbody></table><p><strong>三. /var 的意义与内容：</strong></p><p>如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有：</p><table><thead><tr><th>目录</th><th>应放置文件内容</th></tr></thead><tbody><tr><td>/var/cache/</td><td>应用程序本身运作过程中会产生的一些暂存档</td></tr><tr><td>/var/lib/</td><td>程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去</td></tr><tr><td>/var/lock/</td><td>某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用</td></tr><tr><td>/var/log/</td><td>非常重要。这是登录文件放置的目录。里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。</td></tr><tr><td>/var/mail/</td><td>放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。</td></tr><tr><td>/var/run/</td><td>某些程序或者是服务启动后，会将他们的PID放置在这个目录下</td></tr><tr><td>/var/spool/</td><td>这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中。</td></tr></tbody></table><p>由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。</p><h1 id="常用Linux命令"><a href="#常用Linux命令" class="headerlink" title="常用Linux命令"></a>常用Linux命令</h1><h2 id="常用Linux命令的基本使用"><a href="#常用Linux命令的基本使用" class="headerlink" title="常用Linux命令的基本使用"></a>常用Linux命令的基本使用</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ls</td><td>list</td><td>查看当前文件夹下的内容</td></tr><tr><td>02</td><td>pwd</td><td>print work directory</td><td>查看当前所在文件夹</td></tr><tr><td>03</td><td>cd [目录名]</td><td>change directory</td><td>切换文件夹</td></tr><tr><td>04</td><td>touch [文件名]</td><td>touch</td><td>如果<strong>文件不存在</strong>，新建文件</td></tr><tr><td>05</td><td>mkdir [目录名]</td><td>make directory</td><td>创建目录</td></tr><tr><td>06</td><td>rm [文件名]</td><td>remove</td><td>删除指定文件</td></tr><tr><td>07</td><td>clear</td><td>clear</td><td>清屏</td></tr></tbody></table><p><strong>小技巧：</strong></p><ul><li><code>ctrl + shift + =</code> <strong>放大</strong>终端窗口的字体显示</li><li><code>ctrl + -</code> <strong>缩小</strong>终端窗口的字体显示</li></ul><h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p>在敲出 <code>文件</code> ／ <code>目录</code> ／ <code>命令</code> 的前几个字母之后，按下 tab 键</p><ul><li>如果输入的没有歧义，系统会自动补全</li><li>如果还存在其他 <code>文件</code> ／ <code>目录</code> ／ <code>命令</code> ，再按一下 tab 键，系统会提示可能存在的命令</li><li>按 <code>上</code> ／ <code>下</code> 光标键可以在曾经使用过的命令之间来回切换</li><li>如果想要退出选择，并且不想执行当前选中的命令，可以按 <code>ctrl + c</code></li></ul><h1 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h1><h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><p>find 命令功能非常强大，通常用来在 特定的目录下 搜索 符合条件的文件</p><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>find [路径] -name “*.py”</td><td>查找指定路径下扩展名是 .py 的文件，包括子目录</td></tr></tbody></table><ul><li><p>如果省略路径，表示在当前文件夹下查找</p></li><li><p>之前学习的通配符，在使用 find 命令时同时可用</p><p>下面是一些例子</p></li><li><p>1.搜索桌面目录下，文件名包含 1 的文件</p></li></ul><pre class=" language-c"><code class="language-c">find <span class="token operator">-</span>name <span class="token string">"*1*"</span></code></pre><ul><li>2.搜索桌面目录下，所有以 .txt 为扩展名的文件</li></ul><pre class=" language-c"><code class="language-c">find <span class="token operator">-</span>name <span class="token string">"*.txt"</span></code></pre><ul><li>3.搜索桌面目录下，以数字 1 开头的文件</li></ul><pre class=" language-c"><code class="language-c">find <span class="token operator">-</span>name <span class="token string">"1*"</span></code></pre><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><table><thead><tr><th>序 号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ln -s 被链接的源文件 链接文件</td><td>建立文件的软链接，用通俗的方式讲类似于 Windows 下的快捷方式</td></tr></tbody></table><p>注意：</p><ol><li>没有 <code>-s</code> 选项建立的是一个 硬链接文件两个文件占用相同大小的硬盘空间，工作中<strong>几乎不会建立文件的硬链接</strong></li><li>源文件要<strong>使用绝对路径</strong>，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用</li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol><li>将桌面目录下的 01.py 移动到 demo/b/c 目录下</li><li>在桌面目录下新建 01.py 的 软链接 FirstPython分别使用 相对路径 和 绝对路径 建立 FirstPython 的软链接</li><li>将 FirstPython 移动到 demo 目录下，对比使用 相对路径 和 绝对路径 的区别</li></ol><h2 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h2><ul><li>打包压缩 是日常工作中备份文件的一种方式</li><li>在不同操作系统中，常用的打包压缩方式是不同的选项 含义<br>Windows 常用 rar<br>Mac 常用 zip<br>Linux 常用 tar.gz</li></ul><h3 id="打包-／-解包"><a href="#打包-／-解包" class="headerlink" title="打包 ／ 解包"></a>打包 ／ 解包</h3><p><code>tar</code> 是 Linux 中最常用的 <strong>备份</strong>工具，此命令可以 <strong>把一系列文件</strong> 打包到 一个<strong>大文件</strong>中，也可以把一个 打包的大文件恢复成一系列文件<br><code>tar</code> 的命令格式如下:</p><pre class=" language-c"><code class="language-c"># 打包文件tar <span class="token operator">-</span>cvf 打包文件<span class="token punctuation">.</span>tar 被打包的文件／路径<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span># 解包文件tar <span class="token operator">-</span>xvf 打包文件<span class="token punctuation">.</span>tar<span class="token number">1234</span></code></pre><p><strong>tar选项说明：</strong></p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>c</td><td>生成档案文件，创建打包文件</td></tr><tr><td>x</td><td>解开档案文件</td></tr><tr><td>v</td><td>列出归档解档的详细过程，显示进度</td></tr><tr><td>f</td><td>指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后</td></tr></tbody></table><p>注意： <strong>f 选项必须放在最后，其他选项顺序可以随意</strong></p><h2 id="压缩／解压缩"><a href="#压缩／解压缩" class="headerlink" title="压缩／解压缩"></a>压缩／解压缩</h2><h3 id="1）gzip"><a href="#1）gzip" class="headerlink" title="1）gzip"></a>1）gzip</h3><ul><li>tar 与 gzip 命令结合可以使用实现文件 打包和压缩<br>tar 只负责打包文件，但不压缩<br>用 gzip 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.gz</li></ul><blockquote><p>在 Linux 中，最常见的压缩文件格式就是 xxx.tar.gz</p></blockquote><ul><li>在 tar 命令中有一个选项 -z 可以调用 gzip ，从而可以方便的实现压缩和解压缩的</li><li>功能命令格式如下：</li></ul><pre class=" language-c"><code class="language-c"># 压缩文件tar <span class="token operator">-</span>zcvf 打包文件<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz 被压缩的文件／路径<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span># 解压缩文件tar <span class="token operator">-</span>zxvf 打包文件<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz# 解压缩到指定路径tar <span class="token operator">-</span>zxvf 打包文件<span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz <span class="token operator">-</span>C 目标路径</code></pre><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-C</td><td>解压缩到指定目录，注意：<strong>要解压缩的目录必须存在</strong></td></tr></tbody></table><h3 id="2-bzip2-two"><a href="#2-bzip2-two" class="headerlink" title="2) bzip2(two)"></a>2) bzip2(two)</h3><ul><li>tar 与 bzip2 命令结合可以使用实现文件 打包和压缩（用法和 gzip 一样）<br>tar 只负责打包文件，但不压缩<br>用 bzip2 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.bz2</li><li>在 tar 命令中有一个选项 -j 可以调用 bzip2 ，从而可以方便的实现压缩和解压缩的功能</li><li>命令格式如下：</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 压缩文件</span><span class="token function">tar</span> -jcvf 打包文件.tar.bz2 被压缩的文件／路径<span class="token punctuation">..</span>.<span class="token comment" spellcheck="true"># 解压缩文件</span><span class="token function">tar</span> -jxvf 打包文件.tar.bz2</code></pre><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="通过-apt-安装／卸载软件"><a href="#通过-apt-安装／卸载软件" class="headerlink" title="通过 apt 安装／卸载软件"></a>通过 apt 安装／卸载软件</h3><p>apt-get是linux中APT软件包的管理工具。采用shell命令行的方式完成软件的安装、更新、卸载等操作。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>选项：</p><p>-c —— 指定配置文件</p><p>-o —— 直接指定配置参数</p><p>参数：</p><p>管理指令：对APT软件包的管理操作</p><p>软件包：指定要操控的软件包</p><h4 id="软件库"><a href="#软件库" class="headerlink" title="软件库"></a>软件库</h4><p>在使用apt-get 命令之前要引入必须的软件库。软件库也就是软件包的集合，它们存在互联网上的一些公共站点上。当我们需要安装、更新软件时，系统会自动从指定公共站点上搜索相关软件。因此使用apt-get指令的大前提是系统能够连接外网。公共站点的地址在配置文件/etc/apt/source.list中配置的。其格式如下：</p><pre><code>deb  [web或ftp地址]  [发行版名字]  [main/contib/non-free]</code></pre><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h4><p><strong>1 apt-get update —— 更新软件包信息库</strong></p><p>更新软件包信息库。在修改/etc/apt/sources.list或者/etc/apt/preferences之后运行该命令。在Debian中，软件包是通过一个数据库来管理的，通过这个数据库可跟踪系统中已安装、没有安装和现在可安装的软件包信息。apt-get安装软件包时就是依靠这个数据库来解决软件包间的依赖关系，从而可自动安装相关软件。另外需定期运行该命令，从而保持数据库的信息为最新。</p><p><strong>2 apt-get upgrade —— 更新所有已安装的软件包</strong></p><p>软件包升级功能是APT系统这么成功的主要原因。通过该命令，我们就可把软件升级到最新版本。在使用该命令前，最好先运行apt-get update命令，以更新软件包数据库。但该方案不是更新系统最好的方法，一些包会因为包依赖问题而保留(kept back)一些旧的软件包。Debian提供了一个更好的升级方案，就是用dis-upgrade。</p><p><strong>3 apt-get dist-upgrade —— 更新整个Debian系统</strong></p><p>更新整个Debian系统。可从网络或本地更新整个系统。它会重新安排好包的依赖性。如果有些包由于一些原因实在不能更新，我们可通过以下命令查询原因：<br># apt-get -o Debug::pkgProblemResolver=yes dist-upgrade<br>可用apt-show-versions -u可获得可升级软件包的列表。该命令还有一些有用的选项，可用-h选项查看详细帮助，了解更多功能。</p><p><strong>4 apt-get install *packagename* —— 安装新软件包</strong></p><p>安装一个新软件包。如果软件包需其它软件包支持，apt-get会通过搜索软件包数据库找到这种依赖关系，一起下载相关软件。在一个命令行中可同时安装多个软件包，中间用空格隔开即可。安装的软件包默认会存放在/var/cache/apt/archives目录下，以便以后重新安装。如果已安装的软件包损坏了，你可通过–reinstall选项来重新安装。如：</p><pre><code># apt-get --reinstall install package_name1</code></pre><p>在需安装的软件包名后加一个减号会删除软件包，如：apt-get install <em>package_name</em>-。</p><p><strong>5 apt-get remove *packagename* —— 卸载已安装软件包（保留配置文件）</strong></p><p>如果想删除没用的软件包，只要使用该命令即可。此命令会保留软件的配置文件。不删除依赖软件包，且保留配置文件。</p><p><strong>6 apt-get –purge remove *package_name* ——卸载已安装软件包（不保留配置文件）</strong></p><p>如果想把该软件的配置文件也删除，可以用–purge选项。类似地，在删除软件包名后加一个加号会安装软件包，如：apt-get remove package_name+。<br>不删除依赖软件包，删除配置文件。</p><p><strong>7 apt-get autoremove *packagename* —— 卸载已安装软件包（卸载依赖软件）</strong></p><p>删除为了满足依赖而安装的，但现在不再需要的软件包（包括已安装包），保留配置文件。</p><p><strong>8 apt-get autoclean —— 删除已卸载软件的安装包</strong></p><p>apt会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以使用这个命令来清除那些已经卸载的软件包的.deb文件。通过这种方式，可以释放大量的磁盘空间。如果对空间的需求十分迫切，可以使用apt-get clean以释放更多空间。</p><p><strong>9 apt-get clean —— 删除已卸载和已安装软件的安装包</strong></p><p>删除安装的软件的备份。当我们通过apt-get安装软件包时，APT会把软件包下载到本地/var/cache/apt/archives/目录。该命令会删除该文件夹内的除锁住外的所有软件包。</p><p><strong>10 apt-file search filename</strong></p><p>查找包含特定文件的软件包（不一定是已安装的），这些文件的文件名中含有指定的字符串。apt-file是一个独立的软件包。您必须先使用apt-get install来安装它，然後运行apt-file update。如果apt-file search filename输出的内容太多，您可以尝试使用apt-file search filename | grep -w filename（只显示指定字符串作为完整的单词出现在其中的那些文件名）或者类似方法，例如：apt-file search filename | grep /bin/（只显示位于诸如/bin或/usr/bin这些文件夹中的文件，如果您要查找的是某个特定的执行文件的话，这样做是有帮助的）。</p><p><strong>11 apt-get source package_name</strong></p><p>下载软件包的的源码版本。</p><h1 id="文件和目录常用命令"><a href="#文件和目录常用命令" class="headerlink" title="文件和目录常用命令"></a>文件和目录常用命令</h1><h2 id="查看目录内容"><a href="#查看目录内容" class="headerlink" title="查看目录内容"></a>查看目录内容</h2><h3 id="ls-命令说明"><a href="#ls-命令说明" class="headerlink" title="ls 命令说明"></a>ls 命令说明</h3><ul><li>ls 是英文单词 list 的简写，其功能为列出目录的内容，是用户最常用的命令之一，类似于 DOS下的 dir 命令</li></ul><h3 id="Linux-下文件和目录的特点"><a href="#Linux-下文件和目录的特点" class="headerlink" title="Linux 下文件和目录的特点"></a>Linux 下文件和目录的特点</h3><ul><li>Linux 文件 或者 目录 名称最长可以有 256 个字符参数 含义</li><li>以 . 开头的文件为隐藏文件，需要用 -a 参数才能显示</li><li>. 代表当前目录</li><li>… 代表上一级目录</li></ul><h3 id="ls-常用选项"><a href="#ls-常用选项" class="headerlink" title="ls 常用选项"></a>ls 常用选项</h3><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>显示指定目录下所有子目录与文件，包括隐藏文件</td></tr><tr><td>-l</td><td>以列表方式显示文件的详细信息</td></tr><tr><td>-h</td><td>配合 -l 以人性化的方式显示文件大小</td></tr></tbody></table><h3 id="ls通配符的使用"><a href="#ls通配符的使用" class="headerlink" title="ls通配符的使用"></a>ls通配符的使用</h3><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>代表任意个数个字符</td></tr><tr><td>?</td><td>代表任意一个字符，至少 1 个</td></tr><tr><td>[]</td><td>表示可以匹配字符组中的任一一个</td></tr><tr><td>[abc]</td><td>匹配 a、b、c 中的任意一个</td></tr><tr><td>[a-f]</td><td>匹配从 a 到 f 范围内的的任意一个字符</td></tr></tbody></table><p>注意：以 . 开头的文件为隐藏文件，需要用 -a 参数才能显示</p><h2 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h2><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p><code>cd</code> 是英文单词 change directory 的简写，其功能为更改当前的工作目录，也是用户<strong>最常用的命令之一</strong><br>注意：Linux 所有的 目录 和 文件名 都是大小写敏感的</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>cd</td><td>切换到当前用户的主目录(/home/用户目录)</td></tr><tr><td>cd ~</td><td>切换到当前用户的主目录(/home/用户目录)</td></tr><tr><td>cd .</td><td>保持在当前目录不变</td></tr><tr><td>cd …</td><td>切换到上级目录</td></tr><tr><td>cd -</td><td>可以在最近两次工作目录之间来回切换</td></tr></tbody></table><h3 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h3><p>相对路径 在输入路径时，最前面不是 / 或者 ~，表示相对当前目录所在的目录位置<br>绝对路径 在输入路径时，最前面是 / 或者 ~，表示从 <strong>根目录/home目录</strong> 开始的具体目录位置</p><h2 id="创建和删除操作"><a href="#创建和删除操作" class="headerlink" title="创建和删除操作"></a>创建和删除操作</h2><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><ul><li>创建文件或修改文件时间<br>如果文件 不存在，可以创建一个空白文件<br>如果文件 已经存在，可以修改文件的末次修改日期</li></ul><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><ul><li>创建一个新的目录</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-p</td><td>可以递归创建目录</td></tr></tbody></table><p><strong>新建目录的名称 不能与当前目录中 已有的目录或文件 同名</strong></p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><ul><li>删除文件或目录<br>使用 rm 命令要小心，因为文件删除后不能恢复</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-f</td><td>强制删除，忽略不存在的文件，无需提示</td></tr><tr><td>-r</td><td>递归地删除目录下的内容，<strong>删除文件夹 时必须加此参数</strong></td></tr></tbody></table><h2 id="拷贝和移动文件"><a href="#拷贝和移动文件" class="headerlink" title="拷贝和移动文件"></a>拷贝和移动文件</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>tree [目录名]</td><td>tree</td><td>以树状图列出文件目录结构</td></tr><tr><td>02</td><td>cp 源文件目标文件</td><td>copy</td><td>复制文件或者目录</td></tr><tr><td>03</td><td>mv 源文件 目标文件</td><td>move</td><td>移动文件或者目录／文件或者目录重命名</td></tr></tbody></table><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><ul><li>tree 命令可以以树状图列出文件目录结构</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-d</td><td>只显示目录</td></tr></tbody></table><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><ul><li>cp 命令的功能是将给出的 <strong>文件 或 目录</strong> 复制到另一个 <strong>文件 或 目录</strong> 中，相当DOS 下的 copy命令</li></ul><table><thead><tr><th>选 项</th><th>含义</th></tr></thead><tbody><tr><td>-i</td><td>覆盖文件前提示</td></tr><tr><td>-r</td><td>若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必</td></tr></tbody></table><p>须为一个目录名</p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><ul><li>mv 命令可以用来 移动 文件 或 目录，也可以给 文件或目录重命名</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-i</td><td>覆盖文件前提示</td></tr></tbody></table><h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><table><thead><tr><th>序 号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>cat 文件名</td><td>concatenate</td><td>查看文件内容、创建文件、文件合并、追加文件内容等功能</td></tr><tr><td>02</td><td>more 文件名</td><td>more</td><td>分屏显示文件内容</td></tr><tr><td>03</td><td>grep 搜索文本 文件名</td><td>grep</td><td>搜索文本文件内容</td></tr></tbody></table><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>cat 命令可以用来 查看文件内容、创建文件、文件合并、追加文件内容 等功能<br>cat 会一次显示所有的内容，适合 查看内容较少 的文本文件</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-b</td><td>对非空输出行编号</td></tr><tr><td>-n</td><td>对输出的所有行编号</td></tr></tbody></table><p>Linux 中还有一个 nl 的命令和 cat -b 的效果等价</p><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><ul><li>more 命令可以用于分屏显示文件内容，每次只显示一页内容</li><li>适合于 查看内容较多的文本文件</li></ul><p>使用 more 的操作键：</p><table><thead><tr><th>操作键</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>显示手册页的下一屏</td></tr><tr><td>Enter</td><td>键 一次滚动手册页的一行</td></tr><tr><td>b</td><td>回滚一屏</td></tr><tr><td>f</td><td>前滚一屏</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>/word</td><td>搜索 word 字符串</td></tr></tbody></table><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>Linux 系统中 grep 命令是一种强大的文本搜索工具<br>grep 允许对文本文件进行 模式查找，所谓模式查找，又被称为正则表达式。</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-n</td><td>显示匹配行及行号</td></tr><tr><td>-v</td><td>显示不包含匹配文本的所有行（相当于求反）</td></tr><tr><td>-i</td><td>忽略大小写</td></tr></tbody></table><p>常用的两种模式查找</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>^a</td><td>行首，搜寻以 a 开头的行</td></tr><tr><td>ke$</td><td>行尾，搜寻以 ke 结束的行</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="echo-文字内容"><a href="#echo-文字内容" class="headerlink" title="echo 文字内容"></a>echo 文字内容</h3><p>echo 会在终端中显示参数指定的文字，通常会和 重定向 联合使用</p><h3 id="重定向-gt-和-gt-gt"><a href="#重定向-gt-和-gt-gt" class="headerlink" title="重定向 > 和 >>"></a>重定向 &gt; 和 &gt;&gt;</h3><p>Linux 允许将命令执行结果 重定向到一个 文件<br>将本应显示在终端上的内容 输出／追加 到指定文件中<br>其中<br>**&gt; 表示输出，会覆盖文件原有的内容**<br><strong>&gt;&gt; 表示追加，会将内容追加到已有文件的末尾</strong></p><h3 id="管道"><a href="#管道" class="headerlink" title="管道 |"></a>管道 |</h3><ul><li>Linux 允许将 一个命令的输出 可以通过管道 做为 另一个命令的输入</li><li>可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里 | 的左右分为两端，<br>左端塞东西（写），右端取东西（读）</li></ul><p>常用的管道命令有：</p><ul><li>more ：分屏显示内容</li><li>grep ：在命令执行结果的基础上查询指定的文本</li></ul><h1 id="系统信息相关命令"><a href="#系统信息相关命令" class="headerlink" title="系统信息相关命令"></a>系统信息相关命令</h1><h2 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>date</td><td>查看系统时间</td></tr><tr><td>02</td><td>cal</td><td>calendar 查看日历， -y 选项可以查看一年的日历</td></tr></tbody></table><h2 id="磁盘信息"><a href="#磁盘信息" class="headerlink" title="磁盘信息"></a>磁盘信息</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>df -h</td><td>disk free 显示磁盘剩余空间</td></tr><tr><td>02</td><td>du -h [目录名]</td><td>disk usage 显示目录下的文件大小</td></tr></tbody></table><h2 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h2><p>所谓<strong>进程</strong>，通俗地说就是 <strong>当前正在执行的一个程序</strong></p><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ps aux</td><td>process status 查看进程的详细状况</td></tr><tr><td>02</td><td>top</td><td>动态显示运行中的进程并且排序</td></tr><tr><td>03</td><td>kill [-9] 进程代号</td><td>终止指定代号的进程， -9 表示强行终止</td></tr></tbody></table><p>ps 默认只会显示当前用户通过终端启动的应用程序<br>ps 选项说明</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>a</td><td>显示终端上的所有进程，包括其他用户的进程</td></tr><tr><td>u</td><td>显示进程的详细状态</td></tr><tr><td>x</td><td>显示没有控制终端的进程</td></tr></tbody></table><p>提示：使用 kill 命令时，最好只终止由当前用户开启的进程，而不要终止 root 身份开启的进程，否则可能导致系统崩溃</p><ul><li>要退出 top 可以直接输入 q</li></ul><h1 id="用户权限相关命令"><a href="#用户权限相关命令" class="headerlink" title="用户权限相关命令"></a>用户权限相关命令</h1><h2 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h2><p>提示：创建组 / 删除组 的终端命令都需要通过 sudo 执行</p><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>groupadd 组名</td><td>添加组</td></tr><tr><td>02</td><td>groupdel 组名</td><td>删除组</td></tr><tr><td>03</td><td>cat /etc/group</td><td>确认组信息</td></tr><tr><td>04</td><td>chgrp -R 组名 文件/目录名</td><td>递归修改文件/目录的所属组</td></tr></tbody></table><p>提示：<br>组信息保存在 /etc/group 文件中<br>/etc 目录是专门用来保存 系统配置信息 的目录</p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>提示：创建用户 / 删除用户 / 修改其他用户密码 的终端命令都需要通过 sudo 执行</p><h3 id="创建用户／设置密码／删除用户"><a href="#创建用户／设置密码／删除用户" class="headerlink" title="创建用户／设置密码／删除用户"></a>创建用户／设置密码／删除用户</h3><table><thead><tr><th>序号</th><th>命令</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>useradd -m -g 组 新建用户名</td><td>添加新用户</td><td>-m 自动建立用户家目录 -g 指定用户所在的组，否则会建立一个同名的组</td></tr><tr><td>2</td><td>passwd 用户名</td><td>设置用户密码</td><td>如果是普通用户，直接用passwd可以修改自己的账号密码</td></tr><tr><td>3</td><td>userdel -r 用户名</td><td>删除用户</td><td>-r 选项会自动删除用户家目录</td></tr><tr><td>4</td><td>cat /etc/passed | grep 用户名</td><td>确认用户</td><td>新建用户后，用户信息会保存在 /etc/passwd文件中</td></tr></tbody></table><p>提示：</p><ul><li>创建用户时，如果忘记添加 -m 选项指定新用户的家目录 —— 最简单的方法就是删除用户，重新创建</li><li>创建用户时，默认会创建一个和用户名同名的组名</li><li>用户信息保存在 /etc/passwd 文件中</li></ul><p>在这里推荐一个简便的创建用户的方法，否则在切换用户的时候只出现$问题</p><pre><code>useradd -d /home/tt -m sam -s /bin/bash -g root</code></pre><h3 id="查看用户信息"><a href="#查看用户信息" class="headerlink" title="查看用户信息"></a>查看用户信息</h3><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>id [用户名]</td><td>查看用户 UID 和 GID 信息</td></tr><tr><td>02</td><td>who</td><td>查看当前所有登录的用户列表</td></tr><tr><td>03</td><td>whoami</td><td>查看当前登录用户的账户名</td></tr></tbody></table><h4 id="which（重要）"><a href="#which（重要）" class="headerlink" title="which（重要）"></a>which（重要）</h4><p>提示</p><ul><li>/etc/passwd 是用于保存用户信息的文件</li><li>/usr/bin/passwd 是用于修改用户密码的程序<br>which 命令可以查看执行命令所在位置，例如：</li></ul><pre class=" language-c"><code class="language-c">which ls# 输出# <span class="token operator">/</span>bin<span class="token operator">/</span>lswhich useradd# 输出# <span class="token operator">/</span>usr<span class="token operator">/</span>sbin<span class="token operator">/</span>useradd<span class="token number">123456</span></code></pre><p><strong>bin 和 sbin</strong></p><ul><li>在 Linux 中，绝大多数可执行文件都是保存在 /bin 、 /sbin 、 /usr/bin 、 /usr/sbin</li><li>/bin （ binary ）是二进制执行文件目录，主要用于具体应用</li><li>/sbin （ system binary ）是系统管理员专用的二进制代码存放目录，主要用于系统管理</li><li>/usr/bin （ user commands for applications ）后期安装的一些软件</li><li>/usr/sbin （ super user commands for applications ）超级用户的一些管理程序</li></ul><p>提示：<br>cd 这个终端命令是内置在系统内核中的，没有独立的文件，因此用 which 无法找到 cd命令的位置</p><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><table><thead><tr><th>序 号</th><th>命令</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>01</td><td>su - 用户名</td><td>切换用户，并且切换目录</td><td>- 可以切换到用户家目录，否则保持位置不变</td></tr><tr><td>02</td><td>exit</td><td>退出当前登录账户</td><td></td></tr></tbody></table><p>su 不接用户名，可以切换到 root ，但是不推荐使用，因为不安全<br>exit 示意图如下：</p><h2 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>chown</td><td>修改拥有者</td></tr><tr><td>02</td><td>chgrp</td><td>修改组</td></tr><tr><td>03</td><td>chmod</td><td>修改权限</td></tr></tbody></table><p>命令格式如下：</p><pre class=" language-c"><code class="language-c"># 修改文件<span class="token operator">|</span>目录的拥有者chown 用户名 文件名<span class="token operator">|</span>目录名# 递归修改文件<span class="token operator">|</span>目录的组chgrp <span class="token operator">-</span>R 组名 文件名<span class="token operator">|</span>目录名# 递归修改文件权限chmod <span class="token operator">-</span>R <span class="token number">755</span> 文件名<span class="token operator">|</span>目录名</code></pre><h1 id="远程管理常用命令"><a href="#远程管理常用命令" class="headerlink" title="远程管理常用命令"></a>远程管理常用命令</h1><h2 id="关机-重启"><a href="#关机-重启" class="headerlink" title="关机/重启"></a>关机/重启</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>shutdown</td><td>选项 时间 shutdown</td><td>关机／重新启动</td></tr></tbody></table><p>常用命令示例</p><pre class=" language-c"><code class="language-c"># 重新启动操作系统，其中 now 表示现在$ shutdown <span class="token operator">-</span>r now# 立刻关机，其中 now 表示现在$ shutdown now# 系统在今天的 <span class="token number">20</span><span class="token punctuation">:</span><span class="token number">25</span> 会关机$ shutdown <span class="token number">20</span><span class="token punctuation">:</span><span class="token number">25</span># 系统再过十分钟后自动关机$ shutdown <span class="token operator">+</span><span class="token number">10</span># 取消之前指定的关机计划$ shutdown <span class="token operator">-</span>c</code></pre><p>不指定选项和参数，默认表示 1 分钟之后 关闭电脑<br>远程维护服务器时，最好不要关闭系统，而应该重新启动系统</p><h2 id="查看配置网卡信息"><a href="#查看配置网卡信息" class="headerlink" title="查看配置网卡信息"></a>查看配置网卡信息</h2><table><thead><tr><th>序 号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ifconfig</td><td>configure a network interface</td><td>查看/配置计算机当前的网卡配置信息</td></tr><tr><td>02</td><td>ping ip地址</td><td>ping</td><td>检测到目标 ip地址 的连接是否正常</td></tr></tbody></table><h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h3><p>ifconfig 可以查看／配置计算机当前的网卡配置信息</p><pre class=" language-c"><code class="language-c"># 查看网卡配置信息$ ifconfig# 查看网卡对应的 IP 地址$ ifconfig <span class="token operator">|</span> grep inet</code></pre><p>提示：一台计算机中有可能会有一个 物理网卡 和 多个虚拟网卡，在 Linux 中物理网卡的名字通常以 ensXX 表示<br>127.0.0.1 被称为 <strong>本地回环/环回地址</strong>，一般用来测试本机网卡是否正常</p><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>ping 一般用于检测当前计算机到目标计算机之间的网络 <strong>是否通畅，数值越大，速度越慢</strong></p><pre class=" language-c"><code class="language-c"># 检测到目标主机是否连接正常$ ping IP地址# 检测本地网卡工作正常$ ping <span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span></code></pre><p>ping 的工作原理与潜水艇的声纳相似， ping 这个命令就是取自 声纳的声音<br>网络管理员之间也常将 ping 用作动词 —— ping 一下计算机X，看他是否开着</p><h2 id="远程登录和赋值文件"><a href="#远程登录和赋值文件" class="headerlink" title="远程登录和赋值文件"></a>远程登录和赋值文件</h2><h3 id="ssh-基础（重点）"><a href="#ssh-基础（重点）" class="headerlink" title="ssh 基础（重点）"></a>ssh 基础（重点）</h3><p>在 Linux 中 SSH 是 <strong>常用</strong> 的工具，通过 <strong>SSH 客户端</strong> 我们可以连接到运行了 <strong>SSH 服务器</strong> 的远程机器上。</p><p>SSH是一种安全通道协议，主要用来实现字符界面的远程登录、远程复制等功能。SSH协议对通信双方的数据传输进行了加密处理，其中包括用户登录时输入的用户口令。与早期的telnet、rsh、rcp等应用相比，SSH协议提供了更好的安全性。</p><p>ssh的简单使用：</p><pre class=" language-c"><code class="language-c">ssh <span class="token punctuation">[</span><span class="token operator">-</span>p port<span class="token punctuation">]</span> user@remote</code></pre><ul><li>user 是在远程机器上的用户名，如果不指定的话默认为当前用户</li><li>remote 是远程机器的地址，可以是 IP／域名，或者是 后面会提到的别名</li><li>port 是 SSH Server 监听的端口，如果不指定，就为默认值 22</li><li>之后系统会提示输入密码，输入后即可登录</li></ul><p>提示：</p><ul><li>使用 exit 退出当前用户的登录</li><li>ssh 这个终端命令只能在 Linux 或者 UNIX 系统下使用</li><li>如果在 Windows 系统中，可以安装 PuTTY 或者 XShell 客户端软件即可</li><li>在工作中，SSH 服务器的端口号很有可能<strong>不是 22</strong>，如果遇到这种情况就需要<strong>使用 -p 选项</strong>，指定正确的端口号，否则无法正常连接到服务器</li></ul><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p>scp 就是 secure copy ，是一个在 Linux 下用来进行 <strong>远程拷贝文件</strong> 的命令<br>它的<strong>地址格式与 ssh 基本相同</strong>，需要注意的是，在指定端口时用的是大写的 -P 而不是小写的</p><pre class=" language-c"><code class="language-c"># 把本地当前目录下的 <span class="token number">1</span><span class="token punctuation">.</span>txt 文件 复制到 远程 家目录下的 Desktop<span class="token operator">/</span><span class="token number">1</span><span class="token punctuation">.</span>txt# 注意：`<span class="token punctuation">:</span>` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径scp <span class="token operator">-</span>P port <span class="token number">1</span><span class="token punctuation">.</span>txt user@remote<span class="token punctuation">:</span>Desktop<span class="token operator">/</span><span class="token number">1</span><span class="token punctuation">.</span>txt# 把远程 家目录下的 Desktop<span class="token operator">/</span><span class="token number">1</span><span class="token punctuation">.</span>txt 文件 复制到 本地当前目录下的 <span class="token number">1</span><span class="token punctuation">.</span>txtscp <span class="token operator">-</span>P port user@remote<span class="token punctuation">:</span>Desktop<span class="token operator">/</span><span class="token number">01</span><span class="token punctuation">.</span>py <span class="token number">1</span><span class="token punctuation">.</span>txt# 加上 <span class="token operator">-</span>r 选项可以传送文件夹# 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktopscp <span class="token operator">-</span>r demo user@remote<span class="token punctuation">:</span>Desktop# 把远程家目录下的 Desktop 复制到 当前目录下的 demo 文件夹scp <span class="token operator">-</span>r user@remote<span class="token punctuation">:</span>Desktop demo</code></pre><table><thead><tr><th>选 项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</td></tr><tr><td>-P</td><td>若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端口</td></tr></tbody></table><p>注意：<br>scp 这个终端命令只能在 <code>Linux</code> 或者 <code>UNIX</code> 系统下使用<br>如果在 Windows 系统中，可以安装 PuTTY ，使用 pscp 命令行工具或者安装 FileZilla使用 FTP 进行文件传输</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL--priority_queue</title>
      <link href="2020/10072953.html"/>
      <url>2020/10072953.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、priority-queue的相关定义"><a href="#一、priority-queue的相关定义" class="headerlink" title="一、priority_queue的相关定义"></a>一、priority_queue的相关定义</h2><p>优先队列容器和队列一样，只能从队尾插入元素，从队首删除元素。</p><p>优先队列有一个特性，就是队列中最大的元素总是位于队首，所以出队时，并不是完全一样的遵循先进先出的原则来进行的，而是将队列中最大的元素出队。元素的比较规则默认按照元素值由大到小排序，我们可以重载 “&lt;” 操作符来重新定义比较规则。</p><p>优先队列可以用容器vector 或双向队列（deque）来实现</p><p>优先队列在头文件#include <queue>中；</queue></p><h2 id="二、基本操作"><a href="#二、基本操作" class="headerlink" title="二、基本操作"></a>二、基本操作</h2><p>和队列基本操作相同:</p><ul><li>top 访问队头元素</li><li>empty 队列是否为空</li><li>size 返回队列内元素个数</li><li>push 插入元素到队尾 (并排序)</li><li>emplace 原地构造一个元素并插入队列</li><li>pop 弹出队头元素</li><li>swap 交换内容</li></ul><p>定义：<code>priority_queue&lt;Type, Container, Functional&gt;</code><br><em>Type</em> 就是数据类型，<em>Container</em> 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），<em>Functional</em> 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆<br>一般是：</p><pre><code>//升序队列priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;//降序队列priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</code></pre><p><strong>基本类型例子：</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//对于基础类型 默认是大顶堆</span>    priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> a<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//等同于 priority_queue&lt;int, vector&lt;int>, less&lt;int> > a;</span>    <span class="token comment" spellcheck="true">//             这里一定要有空格，不然成了右移运算符↓</span>    priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> c<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这样就是小顶堆</span>    priority_queue<span class="token operator">&lt;</span>string<span class="token operator">></span> b<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>a<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    b<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"abcd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"cbd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>        b<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*输出4 3 2 1 00 1 2 3 4cbd abcd abc*/</span></code></pre><p><strong>pari的比较，先比较第一个元素，第一个相等比较第二个</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> a<span class="token punctuation">;</span>    pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>a<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span> <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*输出2 51 31 2*/</span></code></pre><p><strong>对于自定义类型</strong></p><p><strong>虽然有限队列有默认的排列顺序，但在很多情况下默认排序并不满足我们的需求，这就需要我们们自定义排列顺序</strong></p><p>less<int>表示数字大的优先级越大<br>greater<int>表示数字小的优先级越大</int></int></p><p>下面两种优先队列的定义是等价的（以int型为例）<br>priority_queue<int>q;<br>priority_queue&lt;int,vector<int> , less<int> &gt;q;（把元素最小的元素放在队首）</int></int></int></p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;queue></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//方法1  　可以在结构体内部重载运算符，改变符号号的功能</span><span class="token keyword">struct</span> tmp1 <span class="token comment" spellcheck="true">//运算符重载&lt;</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token function">tmp1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> tmp1<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> x <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//大顶堆</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//方法2  　可以在结构体内部重载运算符，改变符号号的功能</span><span class="token keyword">struct</span> tmp2 <span class="token comment" spellcheck="true">//重写仿函数</span><span class="token punctuation">{</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>tmp1 a<span class="token punctuation">,</span> tmp1 b<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        <span class="token keyword">return</span> a<span class="token punctuation">.</span>x <span class="token operator">&lt;</span> b<span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//大顶堆</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    tmp1 <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tmp1 <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tmp1 <span class="token function">c</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    priority_queue<span class="token operator">&lt;</span>tmp1<span class="token operator">></span> d<span class="token punctuation">;</span>    d<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    d<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    d<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>d<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> d<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>        d<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    priority_queue<span class="token operator">&lt;</span>tmp1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>tmp1<span class="token operator">></span><span class="token punctuation">,</span> tmp2<span class="token operator">></span> f<span class="token punctuation">;</span>    f<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    f<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    f<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> f<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>        f<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*输出32 1321*/</span></code></pre><p><strong>关于字符 的比较</strong> </p><p>字符中就是字典序最大</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;queue></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    priority_queue<span class="token operator">&lt;</span>string<span class="token operator">></span> a<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//默认为降序排序</span>    a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"abcd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"cbd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"abcde"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>a<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出 ： cbd abcde abcd abc</span></code></pre><h2 id="三、常见用途"><a href="#三、常见用途" class="headerlink" title="三、常见用途"></a>三、常见用途</h2><p>1，解决一些贪心问题；</p><p>2，对dijksta算法进行优化；</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> cost<span class="token punctuation">[</span>MAX_V<span class="token punctuation">]</span><span class="token punctuation">[</span>MAX_V<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> d<span class="token punctuation">[</span>MAX_V<span class="token punctuation">]</span><span class="token punctuation">,</span> V<span class="token punctuation">,</span> s<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//自定义优先队列less比较函数</span><span class="token keyword">struct</span> cmp<span class="token punctuation">{</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token keyword">const</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//因为优先出列判定为!cmp，所以反向定义实现最小值优先</span>        <span class="token keyword">return</span> d<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">></span> d<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">Dijkstra</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    std<span class="token operator">::</span>priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> cmp<span class="token operator">></span> pq<span class="token punctuation">;</span>    pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    d<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pq<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> V<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> d<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>tmp<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                pq<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="四、实现代码"><a href="#四、实现代码" class="headerlink" title="四、实现代码"></a>四、实现代码</h2><p>C++ STL中定义了三种Container Adapter：Stack(LIFO)、Queue(FIFO)和Priority_queue(max heap)。其中priority_queue底层封装的容器默认是vector。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>value_type<span class="token operator">&amp;&amp;</span> _Val<span class="token punctuation">)</span>        <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// insert element at beginning</span>        c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>_STD <span class="token function">move</span><span class="token punctuation">(</span>_Val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">push_heap</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> _Valty<span class="token operator">></span>        <span class="token keyword">void</span> <span class="token function">emplace</span><span class="token punctuation">(</span>_Valty<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> _Val<span class="token punctuation">)</span>        <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// insert element at beginning</span>        c<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>_STD forward<span class="token operator">&lt;</span>_Valty<span class="token operator">></span><span class="token punctuation">(</span>_Val<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">push_heap</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>        <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// test if queue is empty</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    size_type <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>        <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// return length of queue</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    const_reference <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>        <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// return highest-priority element</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> _Val<span class="token punctuation">)</span>        <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// insert value in priority order</span>        c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>_Val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">push_heap</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// erase highest-priority element</span>        <span class="token function">pop_heap</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> comp<span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><h2 id="五、参考博客"><a href="#五、参考博客" class="headerlink" title="五、参考博客"></a>五、参考博客</h2><p>1、<a href="https://blog.csdn.net/qq_42614911/article/details/98743761?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">https://blog.csdn.net/qq_42614911/article/details/98743761?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p><p>2、<a href="https://blog.csdn.net/weixin_36888577/article/details/79937886?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">https://blog.csdn.net/weixin_36888577/article/details/79937886?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p><p>3、<a href="https://www.cnblogs.com/cielosun/p/5654595.html">https://www.cnblogs.com/cielosun/p/5654595.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL--map</title>
      <link href="2020/10079026.html"/>
      <url>2020/10079026.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、map的概述"><a href="#一、map的概述" class="headerlink" title="一、map的概述"></a>一、map的概述</h2><p>map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据 处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。</p><h4 id="1、map简介"><a href="#1、map简介" class="headerlink" title="1、map简介"></a>1、map简介</h4><p>map是一类关联式容器。它的特点是增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。</p><p>对于迭代器来说，可以修改实值，而不能修改key。</p><h4 id="2、map的功能"><a href="#2、map的功能" class="headerlink" title="2、map的功能"></a>2、map的功能</h4><p>自动建立Key － value的对应。key 和 value可以是任意你需要的类型。</p><p>根据key值快速查找记录，查找的复杂度基本是Log(N)，如果有1000个记录，最多查找10次，1,000,000个记录，最多查找20次。</p><p>快速插入Key -Value 记录。</p><p>快速删除记录</p><p>根据Key 修改value记录。</p><p>遍历所有记录。</p><h4 id="3、使用map"><a href="#3、使用map" class="headerlink" title="3、使用map"></a>3、使用map</h4><p>使用map得包含map类所在的头文件</p><p>#include <map> //注意，STL头文件没有扩展名.h</map></p><p>map对象是模板类，需要关键字和存储对象两个模板参数：</p><p>std:map&lt;int,string&gt; personnel;</p><p>这样就定义了一个用int作为索引,并拥有相关联的指向string的指针.</p><p>为了使用方便，可以对模板类进行一下类型定义，</p><p><strong>typedef map&lt;int,CString&gt; UDT_MAP_INT_CSTRING;</strong></p><p><strong>UDT_MAP_INT_CSTRING enumMap;</strong></p><h2 id="二、map的基本操作"><a href="#二、map的基本操作" class="headerlink" title="二、map的基本操作"></a>二、map的基本操作</h2><pre><code>begin()          返回指向map头部的迭代器clear()         删除所有元素count()          返回指定元素出现的次数empty()          如果map为空则返回trueend()            返回指向map末尾的迭代器equal_range()    返回特殊条目的迭代器对erase()          删除一个元素find()           查找一个元素get_allocator()  返回map的配置器insert()         插入元素key_comp()       返回比较元素key的函数lower_bound()    返回键值&gt;=给定元素的第一个位置max_size()       返回可以容纳的最大元素个数rbegin()         返回一个指向map尾部的逆向迭代器rend()           返回一个指向map头部的逆向迭代器size()           返回map中元素的个数swap()            交换两个mapupper_bound()     返回键值&gt;给定元素的第一个位置value_comp()      返回比较元素value的函数</code></pre><h2 id="三、具体操作详解"><a href="#三、具体操作详解" class="headerlink" title="三、具体操作详解"></a>三、具体操作详解</h2><h4 id="1、插入"><a href="#1、插入" class="headerlink" title="1、插入"></a>1、插入</h4><p>在构造map容器后，我们就可以往里面插入数据了。这里讲三种插入数据的方法：</p><h5 id="1-1-用insert函数插入pair数据"><a href="#1-1-用insert函数插入pair数据" class="headerlink" title="1.1 用insert函数插入pair数据"></a>1.1 用insert函数插入pair数据</h5><pre class=" language-cpp"><code class="language-cpp">map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span>m<span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"Lee"</span><span class="token punctuation">,</span><span class="token number">104</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="1-2-用insert函数插入value-type数据"><a href="#1-2-用insert函数插入value-type数据" class="headerlink" title="1.2 用insert函数插入value_type数据"></a>1.2 用insert函数插入value_type数据</h5><pre class=" language-cpp"><code class="language-cpp">map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span>m<span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span><span class="token function">value_type</span><span class="token punctuation">(</span><span class="token string">"Karen"</span><span class="token punctuation">,</span><span class="token number">105</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><h5 id="1-3-数组方式插入数据"><a href="#1-3-数组方式插入数据" class="headerlink" title="1.3 数组方式插入数据"></a>1.3 数组方式插入数据</h5><pre class=" language-cpp"><code class="language-cpp">map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span>m<span class="token punctuation">;</span>m<span class="token punctuation">[</span><span class="token string">"Bob"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">101</span><span class="token punctuation">;</span>    m<span class="token punctuation">[</span><span class="token string">"Alice"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">102</span><span class="token punctuation">;</span>  m<span class="token punctuation">[</span><span class="token string">"Eric"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">103</span><span class="token punctuation">;</span>  </code></pre><p>以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对应的值，用程序说明：</p><pre class=" language-cpp"><code class="language-cpp">m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span><span class="token function">value_type</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"student_one"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span><span class="token function">value_type</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"student_two"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面这两条语句执行后，map中1这个关键字对应的值是“student_one”，第二条语句并没有生效，那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下：</p><pre class=" language-cpp"><code class="language-cpp">pair<span class="token operator">&lt;</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> Insert_Pair<span class="token punctuation">;</span>Insert_Pair <span class="token operator">=</span> mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span><span class="token function">value_type</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"student_one"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。</p><p>下面给出完成代码，演示插入成功与否问题：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> mapStudent<span class="token punctuation">;</span>      pair<span class="token operator">&lt;</span>map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span>iterator<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">></span> Insert_Pair<span class="token punctuation">;</span>      Insert_Pair <span class="token operator">=</span> mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"student_one"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>Insert_Pair<span class="token punctuation">.</span>second <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>          cout<span class="token operator">&lt;&lt;</span><span class="token string">"Insert Successfully"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>      <span class="token keyword">else</span>          cout<span class="token operator">&lt;&lt;</span><span class="token string">"Insert Failure"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>      Insert_Pair <span class="token operator">=</span> mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"student_two"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>Insert_Pair<span class="token punctuation">.</span>second <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>          cout<span class="token operator">&lt;&lt;</span><span class="token string">"Insert Successfully"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>      <span class="token keyword">else</span>          cout<span class="token operator">&lt;&lt;</span><span class="token string">"Insert Failure"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>      map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span>iterator iter<span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span>iter <span class="token operator">=</span> mapStudent<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> mapStudent<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token operator">++</span><span class="token punctuation">)</span>         cout<span class="token operator">&lt;&lt;</span>iter<span class="token operator">-</span><span class="token operator">></span>first<span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token operator">&lt;&lt;</span>iter<span class="token operator">-</span><span class="token operator">></span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre><p>利用数组形式插入数据，则可以覆盖数据，这是不一样的地方</p><h4 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2.遍历"></a>2.遍历</h4><h5 id="2-1-应用前向迭代器"><a href="#2-1-应用前向迭代器" class="headerlink" title="2.1 应用前向迭代器"></a>2.1 应用前向迭代器</h5><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span>m<span class="token punctuation">;</span>    m<span class="token punctuation">[</span><span class="token string">"Bob"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">101</span><span class="token punctuation">;</span>    m<span class="token punctuation">[</span><span class="token string">"Alice"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">102</span><span class="token punctuation">;</span>    m<span class="token punctuation">[</span><span class="token string">"Eric"</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">103</span><span class="token punctuation">;</span>    map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator iter<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>iter<span class="token operator">=</span>m<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token operator">!=</span>m<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token operator">++</span><span class="token punctuation">)</span>        cout<span class="token operator">&lt;&lt;</span>iter<span class="token operator">-</span><span class="token operator">></span>first <span class="token operator">&lt;&lt;</span><span class="token string">"->"</span><span class="token operator">&lt;&lt;</span>iter<span class="token operator">-</span><span class="token operator">></span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出为</p><pre class=" language-cpp"><code class="language-cpp">Alice<span class="token operator">-</span><span class="token operator">></span><span class="token number">102</span>Bob<span class="token operator">-</span><span class="token operator">></span><span class="token number">101</span>Eric<span class="token operator">-</span><span class="token operator">></span><span class="token number">103</span></code></pre><p>可以看到map自动在内部以关键字为准，按字典序排序，而不是根据输入的顺序；</p><p><strong>当询问一个map中不存在的数的时候，返回的值应该是0，不过当你再次遍历的时候，就会发现map中已经多了一个键值对，只不过值是0：</strong></p><h5 id="2-2-应用反相迭代器"><a href="#2-2-应用反相迭代器" class="headerlink" title="2.2 应用反相迭代器"></a>2.2 应用反相迭代器</h5><pre class=" language-cpp"><code class="language-cpp"> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> mapStudent<span class="token punctuation">;</span>      mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"student_one"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"student_two"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"student_three"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> nSize <span class="token operator">=</span> mapStudent<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span>reverse_iterator iter<span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span>iter <span class="token operator">=</span> mapStudent<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> mapStudent<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token operator">++</span><span class="token punctuation">)</span>          cout<span class="token operator">&lt;&lt;</span>iter<span class="token operator">-</span><span class="token operator">></span>first<span class="token operator">&lt;&lt;</span><span class="token string">"  "</span><span class="token operator">&lt;&lt;</span>iter<span class="token operator">-</span><span class="token operator">></span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> </code></pre><h5 id="2-3-用数组的形式"><a href="#2-3-用数组的形式" class="headerlink" title="2.3 用数组的形式"></a>2.3 用数组的形式</h5><pre class=" language-cpp"><code class="language-cpp"> map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> mapStudent<span class="token punctuation">;</span>      mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"student_one"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"student_two"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"student_three"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> nSize <span class="token operator">=</span> mapStudent<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//此处应注意，应该是 for(int nindex = 1; nindex &lt;= nSize; nindex++)  </span><span class="token comment" spellcheck="true">//而不是 for(int nindex = 0; nindex &lt; nSize; nindex++)  </span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> nindex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> nindex <span class="token operator">&lt;=</span> nSize<span class="token punctuation">;</span> nindex<span class="token operator">++</span><span class="token punctuation">)</span>          cout<span class="token operator">&lt;&lt;</span>mapStudent<span class="token punctuation">[</span>nindex<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> </code></pre><h4 id="3-查找"><a href="#3-查找" class="headerlink" title="3.查找"></a>3.查找</h4><h5 id="3-1-用count函数"><a href="#3-1-用count函数" class="headerlink" title="3.1 用count函数"></a>3.1 <strong>用count函数</strong></h5><p>判定关键字是否出现，其缺点是无法定位数据出现位置,由于map的特性，一对一的映射关系，就决定了count函数的返回值只有两个，要么是0，要么是1，出现的情况，当然是返回1了</p><h5 id="3-2-用find函数"><a href="#3-2-用find函数" class="headerlink" title="3.2 用find函数"></a>3.2 <strong>用find函数</strong></h5><p>find()函数定位数据出现位置，它返回的一个迭代器，当数据出现时，它返回数据所在位置的迭代器，如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器。</p><p>查找map中是否包含某个关键字条目用find()方法，传入的参数是要查找的key，在这里需要提到的是begin()和end()两个成员，分别代表map对象中第一个条目和最后一个条目，这两个数据的类型是iterator.</p><pre><code>cout&lt;&lt;m.find("Bob")-&gt;second&lt;&lt;endl;</code></pre><p>如果按关键字搜索，搜不到的话会输出乱码</p><pre><code>   map&lt;string,int&gt;::iterator iter1;    iter1 = m.find(string("Bob"));    if(iter1 != m.end())    cout&lt;&lt;iter1-&gt;first &lt;&lt;"-&gt;"&lt;&lt;iter1-&gt;second&lt;&lt;endl;    else        cout&lt;&lt;"no fount"&lt;&lt;endl;</code></pre><p>定义一个指针，指向map，如果没有的话会返回m.end()</p><h4 id="4-删除"><a href="#4-删除" class="headerlink" title="4.删除"></a>4.删除</h4><p>移除某个map中某个条目用<strong>erase（）</strong></p><p>该成员方法的定义如下：</p><pre><code>iterator erase（iterator it);//通过一个条目对象删除iterator erase（iterator first，iterator last）//删除一个范围size_type erase(const Key&amp;key);//通过关键字删除</code></pre><p>clear()就相当于</p><p>m.erase(m.begin(),m.end());</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>         map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span> mapStudent<span class="token punctuation">;</span>         mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"student_one"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"student_two"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"student_three"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果你要演示输出效果，请选择以下的一种，你看到的效果会比较好  </span>         <span class="token comment" spellcheck="true">//如果要删除1,用迭代器删除  </span>       map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">::</span>iterator iter<span class="token punctuation">;</span>         iter <span class="token operator">=</span> mapStudent<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         mapStudent<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//如果要删除1，用关键字删除  </span>       <span class="token keyword">int</span> n <span class="token operator">=</span> mapStudent<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果删除了会返回1，否则返回0  </span>       <span class="token comment" spellcheck="true">//用迭代器，成片的删除  </span>       <span class="token comment" spellcheck="true">//一下代码把整个map清空  </span>       mapStudent<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span> mapStudent<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mapStudent<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//成片删除要注意的是，也是STL的特性，删除区间是一个前闭后开的集合  </span><span class="token punctuation">}</span>  </code></pre><h4 id="5-swap"><a href="#5-swap" class="headerlink" title="5.swap"></a>5.swap</h4><p>map中的swap不是一个容器中的元素交换，而是两个容器所有元素的交换。</p><h4 id="6-排序"><a href="#6-排序" class="headerlink" title="6.排序"></a>6.排序</h4><p>为了实现快速查找，map内部本身就是按序存储的（例如红黑树），在通过键值对实现查询的时候，就会按照key的大小顺序排序。map默认是从小到大顺序排序，因为map提供了默认的最小比较器</p><p>template &lt; class Key, class T, class Compare = less<key>,</key></p><p>​      class Allocator = allocator&lt;pair&lt;const Key,T&gt; &gt; &gt; class map;</p><p>因此如果是需要指定从大到小排序，与less相对的是greater：</p><p>map中的元素是自动按Key升序排序，所以不能对map用sort函数；</p><p>这里要讲的是一点比较高深的用法了,排序问题，STL中默认是采用小于号来排序的，以上代码在排序上是不存在任何问题的，因为上面的关键字是int 型，它本身支持小于号运算，在一些特殊情况，比如关键字是一个结构体，涉及到排序就会出现问题，因为它没有小于号操作，insert等函数在编译的时候过 不去，下面给出两个方法解决这个问题：</p><p>第一种：小于号重载</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span>  </span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">struct</span> tagStudentinfo  <span class="token punctuation">{</span>         <span class="token keyword">int</span>      niD<span class="token punctuation">;</span>         string   strName<span class="token punctuation">;</span>         <span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>tagStudentinfo <span class="token keyword">const</span><span class="token operator">&amp;</span> _A<span class="token punctuation">)</span> <span class="token keyword">const</span>         <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//这个函数指定排序策略，按niD排序，如果niD相等的话，按strName排序  </span>            <span class="token keyword">if</span><span class="token punctuation">(</span>niD <span class="token operator">&lt;</span> _A<span class="token punctuation">.</span>niD<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>niD <span class="token operator">==</span> _A<span class="token punctuation">.</span>niD<span class="token punctuation">)</span>                  <span class="token keyword">return</span> strName<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>_A<span class="token punctuation">.</span>strName<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>  <span class="token punctuation">}</span>Studentinfo<span class="token punctuation">,</span> <span class="token operator">*</span>PStudentinfo<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//学生信息  </span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">int</span> nSize<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//用学生信息映射分数  </span>    map<span class="token operator">&lt;</span>Studentinfo<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span>mapStudent<span class="token punctuation">;</span>      map<span class="token operator">&lt;</span>Studentinfo<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator iter<span class="token punctuation">;</span>      Studentinfo studentinfo<span class="token punctuation">;</span>      studentinfo<span class="token punctuation">.</span>niD <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      studentinfo<span class="token punctuation">.</span>strName <span class="token operator">=</span> <span class="token string">"student_one"</span><span class="token punctuation">;</span>      mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span>Studentinfo<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>studentinfo<span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      studentinfo<span class="token punctuation">.</span>niD <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>      studentinfo<span class="token punctuation">.</span>strName <span class="token operator">=</span> <span class="token string">"student_two"</span><span class="token punctuation">;</span>      mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span>Studentinfo<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>studentinfo<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>iter<span class="token operator">=</span>mapStudent<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token operator">!=</span>mapStudent<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token operator">++</span><span class="token punctuation">)</span>          cout<span class="token operator">&lt;&lt;</span>iter<span class="token operator">-</span><span class="token operator">></span>first<span class="token punctuation">.</span>niD<span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token operator">&lt;&lt;</span>iter<span class="token operator">-</span><span class="token operator">></span>first<span class="token punctuation">.</span>strName<span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token operator">&lt;&lt;</span>iter<span class="token operator">-</span><span class="token operator">></span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre><p>第二种：仿函数的应用，这个时候结构体中没有直接的小于号重载</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;map></span>  </span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span>  </span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>  <span class="token keyword">typedef</span> <span class="token keyword">struct</span> tagStudentinfo  <span class="token punctuation">{</span>         <span class="token keyword">int</span>      niD<span class="token punctuation">;</span>         string   strName<span class="token punctuation">;</span>  <span class="token punctuation">}</span>Studentinfo<span class="token punctuation">,</span> <span class="token operator">*</span>PStudentinfo<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//学生信息  </span><span class="token keyword">class</span> <span class="token class-name">sort</span>  <span class="token punctuation">{</span>  <span class="token keyword">public</span><span class="token operator">:</span>      <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Studentinfo <span class="token keyword">const</span> <span class="token operator">&amp;</span>_A<span class="token punctuation">,</span> Studentinfo <span class="token keyword">const</span> <span class="token operator">&amp;</span>_B<span class="token punctuation">)</span> <span class="token keyword">const</span>      <span class="token punctuation">{</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>_A<span class="token punctuation">.</span>niD <span class="token operator">&lt;</span> _B<span class="token punctuation">.</span>niD<span class="token punctuation">)</span>              <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>_A<span class="token punctuation">.</span>niD <span class="token operator">==</span> _B<span class="token punctuation">.</span>niD<span class="token punctuation">)</span>              <span class="token keyword">return</span> _A<span class="token punctuation">.</span>strName<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>_B<span class="token punctuation">.</span>strName<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//用学生信息映射分数  </span>    map<span class="token operator">&lt;</span>Studentinfo<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> sort<span class="token operator">></span>mapStudent<span class="token punctuation">;</span>      map<span class="token operator">&lt;</span>Studentinfo<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator iter<span class="token punctuation">;</span>      Studentinfo studentinfo<span class="token punctuation">;</span>      studentinfo<span class="token punctuation">.</span>niD <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      studentinfo<span class="token punctuation">.</span>strName <span class="token operator">=</span> <span class="token string">"student_one"</span><span class="token punctuation">;</span>      mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span>Studentinfo<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>studentinfo<span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      studentinfo<span class="token punctuation">.</span>niD <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>      studentinfo<span class="token punctuation">.</span>strName <span class="token operator">=</span> <span class="token string">"student_two"</span><span class="token punctuation">;</span>      mapStudent<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>pair<span class="token operator">&lt;</span>Studentinfo<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>studentinfo<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>iter<span class="token operator">=</span>mapStudent<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token operator">!=</span>mapStudent<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token operator">++</span><span class="token punctuation">)</span>          cout<span class="token operator">&lt;&lt;</span>iter<span class="token operator">-</span><span class="token operator">></span>first<span class="token punctuation">.</span>niD<span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token operator">&lt;&lt;</span>iter<span class="token operator">-</span><span class="token operator">></span>first<span class="token punctuation">.</span>strName<span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token operator">&lt;&lt;</span>iter<span class="token operator">-</span><span class="token operator">></span>second<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre><p>由于STL是一个统一的整体，map的很多用法都和STL中其它的东西结合在一起，比如在排序上，这里默认用的是小于号，即less&lt;&gt;</p><p>map中由于它内部有序，由红黑树保证，因此很多函数执行的时间复杂度都是log2N的，如果用map函数可以实现的功能，而STL Algorithm也可以完成该功能，建议用map自带函数，效率高一些。</p><h2 id="四、操作时间复杂度"><a href="#四、操作时间复杂度" class="headerlink" title="四、操作时间复杂度"></a>四、操作时间复杂度</h2><p>insert() O(logn)<br>erase() O(logn)<br>find()  O(logn) 找不到返回a.end()<br>lower_bound() O(logn) 查找第一个不小于k的元素<br>upper_bound() O(logn) 查找第一个大于k的元素<br>equal_range() O(logn) 返回pair<br>[key]运算符 O(logn) *** //数组有一个下标，如a[i],这里i是int型的。数组可以认为是从int印射到另一个类型的印射，而map是一个任意的印射，所以i可以是任何类型的！</p><h2 id="五、multimap"><a href="#五、multimap" class="headerlink" title="五、multimap"></a>五、multimap</h2><p>multimap 容器保存的是有序的键/值对，但它可以保存重复的元素。multimap 中会出现具有相同键的元素序列，它们会被添加到容器中。multimap 和 map 有相同范围的构造函数，默认的比较键的函数是 less<k>()。</k></p><p>multimap 大部分成员函数的使用方式和 map 相同。因为重复键的原因，multimap 有一些函数的使用方式和 map 有一些区别。</p><p><strong>接下来介绍 multimap 和 map 容器不同的那些成员函数的用法。</strong></p><p>1.multimap 容器的成员函数 insert() 可以插入一个或多个元素，而且插入总是成功。这个函数有很多的版本都可以插入单个元素，它们都会返回一个指向插入元素的迭代器。</p><pre><code>std::multimap&lt;string, string〉 pets; // Element is pair{pet_type, pet_name}auto iter = pets.insert (std::pair&lt;string, string&gt;{string{"dog"}, string{"Fang"}});iter = pets.insert(iter, std::make_pair("dog", "Spot")); // Insert Spot before Fangpets.insert(std::make_pair("dog", "Rover"));// Inserts Rover after Fangpets.insert (std::make_pair ("cat", "Korky"));// Inserts Korky before all dogspets.insert ({{ "rat", "Roland"}, {"pig", "Pinky" }, {"pig", "Perky"}});//Inserts list elements</code></pre><p>第三条语句的第一个参数是一个作为提示符的迭代器，它说明了元素应该被插入的位置。元素会被立即插入到 iter 所指向元素的前面，因此，这使我们可以覆盖默认的插入位置。对于默认的插入位置来说，元素会被插入到先前插入的键为 “dog” 的元素的后面。元素默认是按照键的升序插入的。如果没有用提示符改变插入位置，有相同键的元素的位置和插入位置相同。最后一条语句插入了一些初始化列表中的元素。有高级版本的 insert()，它可以接收两个迭代器参数，用来指定插入元素的范围。</p><p>2.和 map —样，multimap 的成员函数 emplace() 可以在容器的适当位置构造元素。在插入具有相同键的元素时，可以使用 multimap 的成员函数 emplace_hint()，可以通过为这个函数提供一个迭代器形式的提示符来控制元素的生成位置：</p><pre><code>auto iter = pets.emplace("rabbit”,"Flopsy");iter = pets.emplace_hint (iter, "rabbit", "Mopsy");// Create preceding Flopsy</code></pre><p>这两个函数都返回一个指向插入元素的迭代器。emplace_hint() 函数尽可能近地在第一个参数所指向位置的前面生成一个新元素。如果只使用 emplace() 来插入 “Mopsy”，它可能会被插入到当前所有键为 “rabbit” 的元素的后面。</p><p>3.multimap 不支持下标运算符，因为键并不能确定一个唯一元素。和 map 相似，multimap 也不能使用 at() 函数。multimap 的成员函数 fmd() 可以返回一个键和参数匹配的元素的迭代器。</p><p>4.如果使用 multimap 容器，几乎可以肯定它会包含键重复的元素；否则，就应该使用 map。一般来说，我们想访问给定键对应的所有元素。成员函数 equal_range() 就可以做到这一点。它会返回一个封装了两个迭代器的 pair 对象，这两个迭代器所确定范围内的元素的键和参数值相等。</p><h2 id="六、unordered-map"><a href="#六、unordered-map" class="headerlink" title="六、unordered_map"></a>六、unordered_map</h2><p>unordered_map是c++-11新加的一个标准容器，它提供了一对一的关系，并且在查找速度上能达到O<br>(1)的速度。</p><p> unordered_map底层实现是用哈希桶实现的：</p><p><img src="https://images2018.cnblogs.com/blog/1272978/201806/1272978-20180610192953109-57405861.png" alt="img"></p><p>在unordered_map中，键值通常用于唯一标识元素，而映射值是与该键关联的内容的对象。键和映射值的类型可能不同。</p><p>在内部，unordered_map中的元素<strong>没有按照它们的键值或映射值的任何顺序排序</strong>，而是根据它们的散列值组织成桶以允许通过它们的键值直接快速访问单个元素（具有常数平均时间复杂度）。由于unordered_map内部是用散列表来实现快速查找，因此其内部元素完全是一种无序状态。哈希表利用哈希函数，将关键字的哈希值放都一个桶(bucket)里面，具有相同哈希值的放入到同一个桶。</p><p>unordered_map容器比映射容器更快地通过它们的键来访问各个元素，尽管它们通过其元素的子集进行范围迭代通常效率较低。</p><p>无序映射实现直接访问操作符（operator []），该操作符允许使用其键值作为参数直接访问映射值。</p><p>容器中的迭代器至少是前向迭代器。</p><h4 id="1-std-unordered-map-的定义与特性"><a href="#1-std-unordered-map-的定义与特性" class="headerlink" title="1. std::unordered_map 的定义与特性"></a>1. std::unordered_map 的定义与特性</h4><ul><li><p>所在头文件：**<unordered_map>**</unordered_map></p></li><li><p><strong>std::unorederd_map</strong> 类模板：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Key</span><span class="token punctuation">,</span>                                    <span class="token comment" spellcheck="true">// unordered_map::key_type</span>           <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span>                                      <span class="token comment" spellcheck="true">// unordered_map::mapped_type</span>           <span class="token keyword">class</span> <span class="token class-name">Hash</span> <span class="token operator">=</span> hash<span class="token operator">&lt;</span>Key<span class="token operator">></span><span class="token punctuation">,</span>                       <span class="token comment" spellcheck="true">// unordered_map::hasher</span>           <span class="token keyword">class</span> <span class="token class-name">Pred</span> <span class="token operator">=</span> equal_to<span class="token operator">&lt;</span>Key<span class="token operator">></span><span class="token punctuation">,</span>                   <span class="token comment" spellcheck="true">// unordered_map::key_equal</span>           <span class="token keyword">class</span> <span class="token class-name">Alloc</span> <span class="token operator">=</span> allocator<span class="token operator">&lt;</span> pair<span class="token operator">&lt;</span><span class="token keyword">const</span> Key<span class="token punctuation">,</span>T<span class="token operator">></span> <span class="token operator">></span>  <span class="token comment" spellcheck="true">// unordered_map::allocator_type</span>           <span class="token operator">></span> <span class="token keyword">class</span> <span class="token class-name">unordered_map</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>关联性</strong>：std::unorederd_map 是一个关联容器，其中的元素根据键来引用，而不是根据索引来引用。</p></li><li><p><strong>无序性</strong>：在内部，std::unordered_map中的元素不会根据其键值或映射值按任何特定顺序排序，而是<strong>根据其哈希值组织到桶中</strong>，以允许通过键值直接快速访问各个元素（常量的平均时间复杂度）。</p></li><li><p><strong>唯一性</strong>：std::unorederd_map中的元素的键是唯一的。</p></li></ul><h4 id="2-unordered-map的构造函数"><a href="#2-unordered-map的构造函数" class="headerlink" title="2.unordered_map的构造函数"></a>2.unordered_map的构造函数</h4><pre><code>unordered_map&lt;string,int&gt; mapstring;unordered_map&lt;int,string&gt; mapint;unordered_map&lt;string,char&gt; mapchar;</code></pre><p>其中第一个参数为主值的类型，第二个参数为键值的类型。unordered_map内部使用哈希表进行存储与搜索。</p><h4 id="3-添加数据"><a href="#3-添加数据" class="headerlink" title="3.添加数据"></a>3.添加数据</h4><pre><code>unordere_map&lt;int,string&gt; maplive;//method 1maplive.insert(pair&lt;int,string&gt;(102,"active"));//method 2maplive.insert(unordered_map&lt;int,string&gt;::value_type(321,"hello"));//method 3maplive[112]="April";  //这种方法是最简单用的最多的</code></pre><h4 id="4-查找数据"><a href="#4-查找数据" class="headerlink" title="4.查找数据"></a>4.查找数据</h4><p>find()函数返回一个迭代器指向键值为key的元素，如果没有找到就返回指向map尾部的迭代器。</p><pre><code>unordered_map&lt;int,string&gt;::iterator it;//如果想要偷懒也可以这样写　　　　auto it;it = maplive.find(112);  if(it!=maplive.end())     cout&lt;&lt;"we find key 112.";else     cout&lt;&lt;"we don't find 112.";</code></pre><h4 id="5-unordered-map中元素的删除"><a href="#5-unordered-map中元素的删除" class="headerlink" title="5.unordered_map中元素的删除"></a>5.unordered_map中元素的删除</h4><p>erase(it)函数会删除迭代器it指向的元素。</p><pre><code>//删除键值为112的元素auto it;it=maplive.find(112);if(it==maplive.end())    cout&lt;&lt;"we don't find 112."&lt;&lt;endl;else    maplive.erase(it); //delete 112</code></pre><h4 id="6-unordered-map中元素的查找-count"><a href="#6-unordered-map中元素的查找-count" class="headerlink" title="6.unordered_map中元素的查找 count"></a>6.unordered_map中元素的查找 count</h4><p>count(a)会返回a元素在map中出现的次数，如果没有出现就返回0.</p><h4 id="7-容量操作"><a href="#7-容量操作" class="headerlink" title="7.容量操作"></a>7.容量操作</h4><table><thead><tr><th>函数声明</th><th>解释</th></tr></thead><tbody><tr><td>bool <strong>empty()</strong> const noexcept;</td><td>unordered_map 是否为空</td></tr><tr><td>size_type <strong>size()</strong> const noexcept;</td><td>获取unordered_map 中元素的数量</td></tr></tbody></table><p>boost::unordered_map， 它与 stl::map的区别就是，stl::map是按照operator&lt;比较判断元素是否相同，以及比较元素的大小，然后选择合适的位置插入到树中。所以，如果对map进行遍历（中序遍历）的话，输出的结果是有序的。顺序就是按照operator&lt; 定义的大小排序。</p><p>而boost::unordered_map是计算元素的Hash值，根据Hash值判断元素是否相同。所以，对unordered_map进行遍历，结果是无序的。</p><p>用法的区别就是，stl::map 的key需要定义operator&lt; 。 而boost::unordered_map需要定义hash_value函数并且重载operator==。对于内置类型，如string，这些都不用操心。对于自定义的类型做key，就需要自己重载operator&lt; 或者hash_value()了。 </p><p>当不需要结果排好序时，最好用unordered_map。</p><p>其实，stl::map对于与java中的TreeMap，而boost::unordered_map对应于java中的HashMap。 </p><p>unordered_map需要重载hash_value函数，并重载operator ==运算符。</p><h2 id="六、map和unordered-map的比较汇总"><a href="#六、map和unordered-map的比较汇总" class="headerlink" title="六、map和unordered_map的比较汇总"></a>六、map和unordered_map的比较汇总</h2><p><strong>1.map底层为红黑树查找大致为logN的时间复杂度；unordered_map底层是闭散列的哈希桶，查找为O(1)，性能更优。</strong></p><p><strong>2.调用insert操作，map相较于unordered_map操作慢，大致有2到3倍差异；但是map插入更加稳定</strong></p><p><strong>3.unordered_map的erase操作会缩容，导致元素重新映射，降低性能。</strong></p><p><strong>4.unordered_map要求传入的数据能够进行大小比较，“==”关系比较；所以自定义数据需要定置hash_value仿函数同时重载operator==。</strong></p><p>总的来说</p><p><strong>运行效率方面</strong>：unordered_map最高，而map效率较低但 提供了稳定效率和有序的序列。<br><strong>占用内存方面</strong>：map内存占用略低，unordered_map内存占用略高,而且是线性成比例的。<br>需要无序容器，快速查找删除，不担心略高的内存时用unordered_map；有序容器稳定查找删除效率，内存很在意时候用map。</p><h2 id="七、参考博客"><a href="#七、参考博客" class="headerlink" title="七、参考博客"></a>七、参考博客</h2><p>1、<a href="https://blog.csdn.net/qq_28351609/article/details/84630535">https://blog.csdn.net/qq_28351609/article/details/84630535</a></p><p>2、<a href="https://www.cnblogs.com/dyhaohaoxuexi/p/11257335.html">https://www.cnblogs.com/dyhaohaoxuexi/p/11257335.html</a></p><p>3、<a href="http://c.biancheng.net/view/518.html">http://c.biancheng.net/view/518.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL--queue</title>
      <link href="2020/100613394.html"/>
      <url>2020/100613394.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、queue的简介"><a href="#一、queue的简介" class="headerlink" title="一、queue的简介"></a>一、queue的简介</h2><p>对于queue，用的比较多，所以在这里详细介绍一下queue的用法。</p><p>队列也是一种逻辑数据结构，其具有先进先出的特性，只能在队的前端进行删除， 在队的后端进行插入。针对这种特性，可以实现一些较为复杂的逻辑。在实际应用中，部分程序也正需要这样一种顺序进出的数据处理方式。使用这样的逻辑处理方式，使得我们可以将更多精力放在如何处理顺序逻辑之外的事情，对于编程、开发来讲，提供了极大的方便。</p><p>同stack类似，queue也可以看成是容器的容器，内部是使用其它容器来存放具体数据。加了一个外壳，使得我们的数据操作只能是在头或尾。从尾部添加数据，从头部取数据，从而实现FIFO的特性。同stack一样，内部默认数据存放容器为deque，若要用非默认容器初始化，必须要在模板中指定容器类型。</p><h2 id="二、queue的成员函数"><a href="#二、queue的成员函数" class="headerlink" title="二、queue的成员函数"></a>二、queue的成员函数</h2><p>queue入队，如例：q.push(x); 将x 接到队列的末端。</p><p>queue出队，如例：q.pop(); 弹出队列的第一个元素，注意，并不会返回被弹出元素的值。</p><p>访问queue队首元素，如例：q.front()，即最早被压入队列的元素。</p><p>访问queue队尾元素，如例：q.back()，即最后被压入队列的元素。</p><p>判断queue队列空，如例：q.empty()，当队列空时，返回true。</p><p>访问队列中的元素个数，如例：q.size()</p><h2 id="三、成员函数详细说明"><a href="#三、成员函数详细说明" class="headerlink" title="三、成员函数详细说明"></a>三、成员函数详细说明</h2><h4 id="1、头文件、定义"><a href="#1、头文件、定义" class="headerlink" title="1、头文件、定义"></a>1、头文件、定义</h4><pre><code>#include&lt;queue&gt;queue&lt;Data_Type&gt; name;</code></pre><p>用队列时记得要写上这个头文件。<em>Data_type</em> 为队列要存储数据的类型，<em>name</em> 为该队列的名字。</p><h4 id="2-push"><a href="#2-push" class="headerlink" title="2. push"></a><strong>2. push</strong></h4><p>队列中由于是先进先出，push即在队尾插入一个元素，如：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  queue<span class="token operator">&lt;</span>string<span class="token operator">></span> q<span class="token punctuation">;</span>   q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"China"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   cout<span class="token operator">&lt;&lt;</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="3-pop"><a href="#3-pop" class="headerlink" title="3. pop"></a><strong>3. pop</strong></h4><p>将队列中最靠前位置的元素拿掉，是没有返回值的void函数。如：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> queue<span class="token operator">&lt;</span>string<span class="token operator">></span> q<span class="token punctuation">;</span>  q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"China"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="4-size"><a href="#4-size" class="headerlink" title="4. size"></a><strong>4. size</strong></h4><p>返回队列中元素的个数，返回值类型为unsigned int。如：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  queue<span class="token operator">&lt;</span>string<span class="token operator">></span> q<span class="token punctuation">;</span>   cout<span class="token operator">&lt;&lt;</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>   q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"China"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   cout<span class="token operator">&lt;&lt;</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="5-empty"><a href="#5-empty" class="headerlink" title="5. empty"></a><strong>5. empty</strong></h4><p>判断队列是否为空的，如果为空则返回true。如：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   queue<span class="token operator">&lt;</span>string<span class="token operator">></span> q<span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"China"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  cout<span class="token operator">&lt;&lt;</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="6-front"><a href="#6-front" class="headerlink" title="6. front"></a><strong>6. front</strong></h4><p>返回值为队列中的第一个元素，也就是最早、最先进入队列的元素。注意这里只是返回最早进入的元素，并没有把它剔除出队列。如：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  queue<span class="token operator">&lt;</span>string<span class="token operator">></span> q<span class="token punctuation">;</span>   q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"China"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   cout<span class="token operator">&lt;&lt;</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>   q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   cout<span class="token operator">&lt;&lt;</span>q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="7-back"><a href="#7-back" class="headerlink" title="7. back"></a><strong>7. back</strong></h4><p>返回队列中最后一个元素，也就是最晚进去的元素。如：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  queue<span class="token operator">&lt;</span>string<span class="token operator">></span> q<span class="token punctuation">;</span>   q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"China"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   cout<span class="token operator">&lt;&lt;</span>q<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>C++ stl队列queue示例代码1:</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">int</span> e<span class="token punctuation">,</span>n<span class="token punctuation">,</span>m<span class="token punctuation">;</span>    queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q1<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>      q1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>q1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"dui lie  bu kong\n"</span><span class="token punctuation">;</span>    n<span class="token operator">=</span>q1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>n<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    m<span class="token operator">=</span>q1<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span>m<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>  e<span class="token operator">=</span>q1<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       cout<span class="token operator">&lt;&lt;</span>e<span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>       q1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>q1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"dui lie  kong\n"</span><span class="token punctuation">;</span>    n<span class="token operator">=</span>q1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> cout<span class="token operator">&lt;&lt;</span><span class="token string">"q1.zsize is "</span><span class="token operator">&lt;&lt;</span>n<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="四、queue的实现源码"><a href="#四、queue的实现源码" class="headerlink" title="四、queue的实现源码"></a>四、queue的实现源码</h2><p><strong>STL中queue的实现是默认以deque为底层实现的 ，同样底层也可以是list实现。</strong></p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Squence</span> <span class="token operator">=</span> list<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token operator">></span><span class="token keyword">class</span> <span class="token class-name">Queue</span><span class="token punctuation">{</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> Squence <span class="token operator">::</span> value_type value_type<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> Squence <span class="token operator">::</span> reference reference<span class="token punctuation">;</span>    <span class="token keyword">typedef</span> <span class="token keyword">typename</span> Squence <span class="token operator">::</span> const_reference const_reference<span class="token punctuation">;</span><span class="token keyword">protected</span><span class="token operator">:</span>    Squence c<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>      size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    reference <span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 返回队首的元素</span>    <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//压入元素</span>    reference <span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">--</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//返回队尾元素</span>    <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>c<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//抛出队首元素</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> Queue<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>list<span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> c<span class="token operator">==</span>x<span class="token punctuation">.</span>c <span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Queue<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>list<span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> c<span class="token operator">!=</span>x<span class="token punctuation">.</span>c <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h2 id="五、广度优先搜索"><a href="#五、广度优先搜索" class="headerlink" title="五、广度优先搜索"></a>五、广度优先搜索</h2><p>宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra<a href="http://baike.baidu.com/view/1939816.htm">单源最短路径</a>算法和Prim<a href="http://baike.baidu.com/view/288214.htm">最小生成树</a>算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。</p><p>实现bfs时会需要实现一个队列，用queue可以提高程序的准确性</p><p>另外要注意使用front()和pop()之前最好要使用empty()判断队列非空</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL--set</title>
      <link href="2020/10069761.html"/>
      <url>2020/10069761.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、set-multiset的概述"><a href="#一、set-multiset的概述" class="headerlink" title="一、set/multiset的概述"></a>一、set/multiset的概述</h3><p>​        C++ STL中标准关联容器set, multiset, map, multimap内部采用的就是一种非常高效的平衡检索二叉树：红黑树，也成为RB树(Red-Black Tree)。RB树的统计性能要好于一般平衡二叉树，所以被STL选择作为了关联容器的内部结构。</p><p>​       插入删除操作时仅仅需要指针操作节点即可完成，不涉及到内存移动和拷贝，所以效率比较高。set，顾名思义是“集合”的意思，在set中元素都是唯一的，而且默认情况下会对元素自动进行升序排列，支持集合的交(set_intersection),差(set_difference) 并(set_union)，对称差(set_symmetric_difference) 等一些集合上的操作，如果需要集合中的元素允许重复那么可以使用multiset。</p><p>​      set类似于数学里面的集合，不过set的集合中不包含重复的元素，这是和vector的第一个区别，第二个区别是set内部用平衡二叉树实现，便于元素查找，而vector是使用连续内存存储，便于随机存取。</p><p> 常见的问题所在</p><p>（1）为何map和set的插入删除效率比用其他序列容器高？</p><p>大部分人说，很简单，因为对于关联容器来说，不需要做内存拷贝和内存移动。说对了，确实如此。set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。</p><p>因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点也OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。</p><p>（2）为何每次insert之后，以前保存的iterator不会失效？</p><p>iterator这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)。相对于vector来说，每一次删除和插入，指针都有可能失效，调用push_back在尾部插入也是如此。因为为了保证内部数据的连续存放，iterator指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使时push_back的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。特别时在和find等算法在一起使用的时候，牢记这个原则：不要使用过期的iterator。</p><p>（3）当数据元素增多时，set的插入和搜索速度变化如何？</p><p>如果你知道log2的关系你应该就彻底了解这个答案。在set中查找是使用二分查找，也就是说，如果有16个元素，最多需要比较4次就能找到结果，有32个元素，最多比较5次。那么有10000个呢？最多比较的次数为log10000，最多为14次，如果是20000个元素呢？最多不过15次。看见了吧，当数据量增大一倍的时候，搜索次数只不过多了1次，多了1/14的搜索时间而已。你明白这个道理后，就可以安心往里面放入元素了。<br>（4）set为什么不用hash</p><p>首先set，不像map那样是key-value对，它的key与value是相同的。关于set有两种说法，第一个是STL中的set，用的是红黑树；第二个是hash_set，底层用得是hash table。红黑树与hash table最大的不同是，红黑树是有序结构，而hash table不是。但不是说set就不能用hash，如果只是判断set中的元素是否存在，那么hash显然更合适，因为set 的访问操作时间复杂度是log(N)的，而使用hash底层实现的hash_set是近似O(1)的。然而，set应该更加被强调理解为“集合”，而集合所涉及的操作并、交、差等，即STL提供的如交集set_intersection()、并集set_union()、差集set_difference()和对称差集set_symmetric_difference()，都需要进行大量的比较工作，那么使用底层是有序结构的红黑树就十分恰当了，这也是其相对hash结构的优势所在。</p><p><strong>multiset</strong></p><ul><li>特点</li><li>数据结构：底层实现与set一样，也采用了红黑树</li><li>允许插入重复的键值，使用insert_equal机制</li><li>插入、删除操作的时间复杂度为O(log2n)</li></ul><h3 id="二、set的基本操作"><a href="#二、set的基本操作" class="headerlink" title="二、set的基本操作"></a>二、set的基本操作</h3><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>begin()</td><td>返回容器的第一个迭代器</td></tr><tr><td>end()</td><td>返回容器的最后元素的下一个迭代器</td></tr><tr><td>clear()</td><td>删除容器中的所有元素</td></tr><tr><td>empty()</td><td>判断容器是否为空</td></tr><tr><td>insert()</td><td>插入一个元素</td></tr><tr><td>erase()</td><td>删除一个元素</td></tr><tr><td>size()</td><td>返回当前容器的元素个数</td></tr><tr><td>rbegin()</td><td>返回尾元素的逆向迭代器指针</td></tr><tr><td>reverse_iterator rend()</td><td>返回首元素前一个位置的迭代器指针</td></tr><tr><td>find()</td><td>查找一个元素，不存在返回s.end()</td></tr><tr><td>lower_bound()</td><td>返回第一个大于或等于给定关键值的元素</td></tr><tr><td>upper_bound()</td><td>返回第一个大于给定关键值的元素</td></tr><tr><td>swap()</td><td>交换两个集合元素</td></tr></tbody></table><h3 id="三、set的实现原理"><a href="#三、set的实现原理" class="headerlink" title="三、set的实现原理"></a>三、set的实现原理</h3><ol><li><p>set 的 底层数据结构是 红黑树，一种高效的平衡检索二叉树</p></li><li><p>set 容器中 每一个元素就是二叉树的每一个节点，对于set容器的插入删除操作，效率都比较高，原因是因为二叉树的删除插入元素并不需要进行内存拷贝和内存移动，只是改变了指针的指向</p></li><li><p>对 set 进行插入删除操作 都不会引起iterator的失效，因为迭代器相当于一个指针指向每一个二叉树的节点，对set的插入删除并不会改变原有内存中节点的改变， 但是vector的插入删除操作一般会发生内存移动和内存拷贝，所以会发生迭代器的失效</p></li><li><p>set容器的检索速度很快，因为采用二分查找的方法</p></li></ol><h3 id="四、具体的函数使用和相关示例"><a href="#四、具体的函数使用和相关示例" class="headerlink" title="四、具体的函数使用和相关示例"></a>四、具体的函数使用和相关示例</h3><h4 id="1、set的头文件与声明"><a href="#1、set的头文件与声明" class="headerlink" title="1、set的头文件与声明"></a>1、set的头文件与声明</h4><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;set></span> </span><span class="token comment" spellcheck="true">//头文件</span><span class="token comment" spellcheck="true">//声明 set&lt;类型> 名称</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">;</span>set<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> s<span class="token punctuation">;</span>set<span class="token operator">&lt;</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> s<span class="token punctuation">;</span>multiset<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> s<span class="token punctuation">;</span></code></pre><h4 id="2、set的排序"><a href="#2、set的排序" class="headerlink" title="2、set的排序"></a>2、set的排序</h4><p>set的排序和其他stl容器的操作差不多都是一致的，都需要重新定义操作符&lt;</p><p>下面是一个定义node结构体的一个实例</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">struct</span> node<span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>set<span class="token operator">&lt;</span>node<span class="token operator">></span> s<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> node <span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token keyword">const</span> node <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a<span class="token punctuation">.</span>x<span class="token operator">></span>b<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>自定义比较函数</p><pre class=" language-c++"><code class="language-c++"> (1)元素不是结构体：    例：  //自定义比较函数myComp,重载“（）”操作符struct myComp{    bool operator()(const your_type &a,const your_type &b)    {        return a.data > b.data;    }}set<int,myComp>s;set<int,myComp>::iterator it;  (2)如果元素是结构体，可以直接将比较函数写在结构体内。        例：struct Info{    string name;    float score;    //重载“<”操作符，自定义排序规则    bool operator < (const Info &a) const    {        //按score从大到小排列        return a.score<score;    }}set<Info> s;set<Info>::iterator it;</code></pre><h4 id="3、set-size"><a href="#3、set-size" class="headerlink" title="3、set.size()"></a>3、set.size()</h4><p>统计set中元素个数。函数返回一个整型变量，表示set中元素个数，时间复杂度为O(1)</p><pre><code>int num=s.size();</code></pre><h4 id="4、set-empty"><a href="#4、set-empty" class="headerlink" title="4、set.empty()"></a>4、set.empty()</h4><p>检查set是否为空，返回一个bool型变量，1表示set为空，否则为非空，时间复杂度O(1)</p><pre><code>if(s.empty()){    cout&lt;&lt;"set is empty."&lt;&lt;endl;}</code></pre><h4 id="5、set-count-x"><a href="#5、set-count-x" class="headerlink" title="5、set.count(x)"></a><strong>5、set.count(x)</strong></h4><p>返回set或multiset中值为x的元素个数，时间复杂度为O(log n)</p><pre><code>if(!s.count(x))   ans++;</code></pre><h4 id="6、迭代器"><a href="#6、迭代器" class="headerlink" title="6、迭代器"></a>6、迭代器</h4><p>双向访问迭代器，不支持随机访问，支持星号解除引用，仅支持“++”，“–”这两个算术操作</p><h5 id="引用和操作"><a href="#引用和操作" class="headerlink" title="引用和操作"></a>引用和操作</h5><pre><code>set&lt;int&gt;::inerator it=s.begin();it++;it--</code></pre><p>若把it++，则it将会指向“下一个”元素。这里的下一个是指在key从小到大排序的结果中，排在it下一名的元素。同理，若把it–，则it会指向排在上一个的元素</p><p>“++”，“–”操作的复杂度均为O(log n)</p><h4 id="7、set-begin"><a href="#7、set-begin" class="headerlink" title="7、set.begin()"></a>7、set.begin()</h4><p>返回集合的首迭代器，即指向集合中最小元素的迭代器，时间复杂度为O(1)</p><pre><code>set&lt;int&gt;::inerator it=s.begin();</code></pre><h4 id="8、set-end"><a href="#8、set-end" class="headerlink" title="8、set.end()"></a>8、set.end()</h4><p>返回集合的尾迭代器，众所周知，STL中区间都是左闭右开的，那么end()函数返回的迭代器即为指向集合中最大元素的下一个位置的迭代器，因此–s.end()才是指向集合中最大元素的迭代器，时间复杂度为O(1)</p><h4 id="9、set-insert-x"><a href="#9、set-insert-x" class="headerlink" title="9、set.insert(x)"></a>9、set.insert(x)</h4><p>在set中插入元素，返回插入地址的迭代器和是否插入成功的bool并成的pair，时间复杂度为O(log n)</p><p>PS：set在进行插入的时候是不允许有重复的键值的，如果新插入的键值与原有的键值重复则插入无效（multiset可以重复）</p><h4 id="10、set-erase-参数"><a href="#10、set-erase-参数" class="headerlink" title="10、set.erase(参数)"></a>10、set.erase(参数)</h4><p>删除，参数可以是元素或者迭代器，返回下一个元素的迭代器，时间复杂度为O(log n)，注意在multiset中s.erase(x)会删除所有值为x的元素</p><pre><code>set&lt;int&gt;::inerator it=s.begin();s.erase(it);s.erase(3);</code></pre><h4 id="11、set-find-x"><a href="#11、set-find-x" class="headerlink" title="11、set.find(x)"></a>11、set.find(x)</h4><p>在set中查找值为x的元素，并返回指向该元素的迭代器，若不存在，返回set.end()，时间复杂度为O(log n)</p><pre><code>if(s.find(x)!=s.end())    cout&lt;&lt;"have found!"&lt;&lt;endl</code></pre><h4 id="12、et-lower-bound-x-upper-bound-x"><a href="#12、et-lower-bound-x-upper-bound-x" class="headerlink" title="12、et.lower_bound(x)/upper_bound(x)"></a>12、<strong>et.lower_bound(x)/upper_bound(x)</strong></h4><p>用法与find类似，但查找的条件略有不同，时间复杂度O(log n)</p><p>s.lower_bound(x)表示查找&gt;=x的元素中最小的一个，并返回指向该元素的迭代器</p><p>s.upper_bound(x)表示查找&gt;x的元素中最小的一个，并返回指向该元素的迭代器</p><p>举个例子：</p><p>在set{3,5,7,8,13,16}中</p><p>对于在set中存在的元素，比如<strong>8</strong></p><p><strong>s.lower_bound(8)返回8所在位置的迭代器。</strong></p><p><strong>s.upper_bound(8)返回13所在位置的迭代器。</strong></p><p><strong>对于在set中不存在的元素，比如12，</strong></p><p><strong>两个函数返回的则都是13所在位置的迭代器。</strong></p><p><strong>特殊地，</strong></p><p><strong>对于比set中最大的元素大的元素，比如20，</strong></p><p><strong>两个函数返回的都是s.end()。</strong></p><h4 id="13、set-lt-pair-lt-int-int-gt-gt-的用法"><a href="#13、set-lt-pair-lt-int-int-gt-gt-的用法" class="headerlink" title="13、set<pair<int,int> >的用法"></a>13、set&lt;pair&lt;int,int&gt; &gt;的用法</h4><p>set默认的比较规则先按照first比较，如果first相同，再按照second 比较。 注意：定义的时候右边的两个&gt;&gt;要空一格。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h></span>  </span><span class="token comment" spellcheck="true">//万能头文件</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">define</span> INF 0x3f3f3f3f</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  set<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> s<span class="token punctuation">;</span>  s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  set<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token operator">::</span>iterator it<span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>it<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">!=</span>s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token operator">++</span><span class="token punctuation">)</span>    cout<span class="token operator">&lt;&lt;</span>it<span class="token operator">-</span><span class="token operator">></span>first<span class="token operator">&lt;&lt;</span><span class="token string">' '</span><span class="token operator">&lt;&lt;</span>it<span class="token operator">-</span><span class="token operator">></span>second<span class="token operator">&lt;&lt;</span><span class="token string">"\n"</span><span class="token punctuation">;</span>  it<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">upper_bound</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>it<span class="token operator">!=</span>s<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"(2,4)后面接着是%d %d\n"</span><span class="token punctuation">,</span>it<span class="token operator">-</span><span class="token operator">></span>first<span class="token punctuation">,</span>it<span class="token operator">-</span><span class="token operator">></span>second<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="五、使用set需要注意的事项"><a href="#五、使用set需要注意的事项" class="headerlink" title="五、使用set需要注意的事项"></a>五、使用set需要注意的事项</h3><p>set（集合）——<strong>包含了经过排序了的数据，这些数据的值(value)必须是唯一的。</strong></p><p>set基于<code>红黑树</code>实现，红黑树具有<code>自动排序</code>的功能，因此map内部所有的数据，在任何时候，都是有序的。<code>unordered_set基于哈希表</code>，数据插入和查找的时间复杂度很低，几乎是常数时间，而代价是消耗比较多的内存，<code>无自动排序功能</code>。底层实现上，使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用hash函数对key进行映射到不同区域进行保存。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL--list</title>
      <link href="2020/100655331.html"/>
      <url>2020/100655331.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、list的概述"><a href="#一、list的概述" class="headerlink" title="一、list的概述"></a>一、list的概述</h2><p>list 由双向链表（doubly linked list）实现而成，元素也存放在堆中，每个元素都是放在一块内存中，他的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随机存取变得非常没有效率，因此它没有提供 [] 操作符的重载。但是由于链表的特点，它可以很有效率的支持任意地方的插入和删除操作。</p><p>stl_list其中的增删改查的细节实现本质是一样的，都是处理指针偏移。相比于vector，stl_List在插入和删除的时候可以达到O(1)的时间复杂度。</p><p>stl_list是一个双向循环链表，相对单链表来说查找效率高，无论是插入时的前插和后插，还是从后往前查找某个元素等。既然查找效率高了，自然添加，删除和修改元素时效率也就更高。唯一一个可以称为不足的就是每个节点需要耗费4字节指针来保存前一个节点的地址，因此如果遇到对内存要求比较苛刻的场景，而且一些操作单链表即可满足，那么可以考虑使用标准库中的forward_list（单链表）。</p><h2 id="二、定义和初始化"><a href="#二、定义和初始化" class="headerlink" title="二、定义和初始化"></a>二、定义和初始化</h2><p>使用之前必须加相应容器的头文件：</p><pre><code>#include &lt;list&gt; // list属于std命名域的，因此需要通过命名限定，例如using std::list;</code></pre><p>定义的代码如下：</p><pre class=" language-c++"><code class="language-c++">list<int> a; // 定义一个int类型的列表alist<int> a(10); // 定义一个int类型的列表a，并设置初始大小为10list<int> a(10, 1); // 定义一个int类型的列表a，并设置初始大小为10且初始值都为1list<int> b(a); // 定义并用列表a初始化列表bdeque<int> b(a.begin(), ++a.end()); // 将列表a中的第1个元素作为列表b的初始值</code></pre><p>除此之外，还可以直接使用数组来初始化向量：</p><pre class=" language-c++"><code class="language-c++">int n[] = { 1, 2, 3, 4, 5 };list<int> a(n, n + 5); // 将数组n的前5个元素作为列表a的初值</code></pre><h2 id="三、list的实现原理"><a href="#三、list的实现原理" class="headerlink" title="三、list的实现原理"></a>三、list的实现原理</h2><pre class=" language-c++"><code class="language-c++">#include "stl_def.h"/** @file stl_list.h *  *  This is an stl_list header file, implement double loop list warppes   *  *  Created by yejy on 18-8-18 *  copyright (c) yejy. all rights reserved *  */__YAMI_BEGIN/* stl list  allocate 直接使用默认new/delete */template <typename T>class list{public:  // 不包数据实体，只包含指针和相关操作, 可以认为是节省一个指针大小的内存  struct list_node_base    {    list_node_base* Next;    list_node_base* Prev;    list_node_base():Next(nullptr), Prev(nullptr){}  };  // dataEntry node  struct list_node: public list_node_base  {      T dataEntry;  };  // 迭代器 iterator  struct list_iterator  {    typedef list_iterator   _Self;    typedef T               value_type;    typedef T*              pointer;    typedef T&              reference;    list_iterator() _T_STD_NOEXCEPT    {      m_smartPtr = nullptr;    }    explicit list_iterator(list_node_base * pNode) _T_STD_NOEXCEPT    {      m_smartPtr = pNode;    }    reference operator*() _T_STD_NOEXCEPT    {      return  static_cast<list_node *>(m_smartPtr)->dataEntry;    }    list_node_base* operator->() _T_STD_NOEXCEPT    {      return m_smartPtr;    }    _Self operator++(int) _T_STD_NOEXCEPT // 后 ++    {      _Self __tmp = *this;      m_smartPtr = m_smartPtr->Next;      return __tmp;    }    _Self& operator++() _T_STD_NOEXCEPT // 前 ++    {      m_smartPtr = m_smartPtr->Next;      return *this;    }    _Self operator--(int) _T_STD_NOEXCEPT    {      _Self __tmp = *this;      m_smartPtr = m_smartPtr->Prev;      return __tmp;    }    _Self& operator--() _T_STD_NOEXCEPT    {      m_smartPtr = m_smartPtr->Prev;      return *this;    }    bool operator==(const list_iterator & _Right) const _T_STD_NOEXCEPT    {      return m_smartPtr == _Right.m_smartPtr;    }    bool operator!=(const list_iterator & _Right) const _T_STD_NOEXCEPT    {       return m_smartPtr != _Right.m_smartPtr;    }    list_node_base * m_smartPtr; // 节点指针  };public:  typedef list_iterator iterator;public:  list()  // 默认构造  {     empty_init();  }  list(const list<T> & rhs) // 拷贝构造  {    if(this != &rhs)    {      empty_init(); // 初始化      iterator itrBegin = rhs.begin();      iterator itrEnd = rhs.end();      while(itrBegin != itrEnd)      {         list_node * tmp = static_cast<list_node *>(itrBegin.m_smartPtr);         push_back(tmp->dataEntry);         ++itrBegin;      }    }  }  list & operator = (const list<T> & rhs) // 赋值运算符重载  {    if(this != &rhs)    {      // 如果原来链表有值，则先清空      if(begin() != end())      {        clear();      }      iterator itrBegin = rhs.begin();      iterator itrEnd = rhs.end();      while(itrBegin != itrEnd)      {         list_node * tmp = static_cast<list_node *>(itrBegin.m_smartPtr);         push_back(tmp->dataEntry);         ++itrBegin;      }    }  }  ~list()  {    clear();    if(pHeadNode)    {      delete pHeadNode;      pHeadNode = nullptr;    }  }  iterator begin() _T_STD_NOEXCEPT  {    return iterator(pHeadNode->Next);  }  iterator end() _T_STD_NOEXCEPT  {    return iterator(pHeadNode);  }  void push_back(const T & value)  {    insert(end(), value);  }  void push_front(const T & value)  {    insert(begin(), value);  }  void pop_front()   {     erase(begin());   }  void pop_back()   {     iterator tmp = end();    erase(--tmp);  }  T & front()  {    return *begin();  }  T & back()  {    return *(--end());  }  unsigned int remove(const T & value)  {    unsigned int count = 0;    iterator itrBegin = begin();    while(itrBegin != end())    {      if(*itrBegin == value)      {        itrBegin = erase(itrBegin);        ++count;      }      else      {        ++itrBegin;      }    }    return count;  }  iterator erase(iterator position)  {    list_node_base* next_node = position.m_smartPtr->Next;    list_node_base* prev_node = position.m_smartPtr->Prev;    prev_node->Next = next_node;    next_node->Prev = prev_node;    delete position.m_smartPtr;    position.m_smartPtr = nullptr;    if(_size > 0)    {      _size--;    }    return iterator(next_node);  }  iterator insert(iterator position, const T& x)   {    list_node* tmp = new list_node();    tmp->dataEntry = x;    tmp->Next = position.m_smartPtr;    tmp->Prev = position.m_smartPtr->Prev;    position.m_smartPtr->Prev->Next = tmp;    position.m_smartPtr->Prev = tmp;    ++_size;    return iterator(tmp);  }  void clear()  {    iterator itrBegin = begin();    while(itrBegin != end())    {      list_node* tmp =  static_cast<list_node *>(itrBegin.m_smartPtr);      ++itrBegin;      if(tmp)      {        delete tmp; // 差点犯了一个错误，delete会对用析构函数，并且释放内存。 需要析构子类还是父类，一定要传入正确类型      }    }    pHeadNode->Next = pHeadNode;    pHeadNode->Prev = pHeadNode;    _size = 0;  }  int size()  {    return _size;  }private:  void empty_init()   {     pHeadNode = new list_node_base();    pHeadNode->Next = pHeadNode;  // 初始化指针指向自己    pHeadNode->Prev = pHeadNode;    _size = 0;  }private:  list_node_base* pHeadNode; // 链表头  unsigned int _size; // 链表个数，提高查找效率，如果想为了节省内存，可以不要，临时查找};__YAMI_END</code></pre><p>如果想具体看源码的实现，下面提供一个github的源代码</p><p><a href="https://github.com/Yejy813/stl_implement">stl_implement</a></p><h2 id="四、基本函数"><a href="#四、基本函数" class="headerlink" title="四、基本函数"></a>四、基本函数</h2><h3 id="1、容量函数"><a href="#1、容量函数" class="headerlink" title="1、容量函数"></a>1、容量函数</h3><ul><li>容器大小：size();</li><li>容器最大容量：max_size();</li><li>更改容器大小：resize();</li><li>容器判空：empty();</li></ul><p>代码示例</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        lst<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> lst<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：6</span>    cout <span class="token operator">&lt;&lt;</span> lst<span class="token punctuation">.</span><span class="token function">max_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：357913941</span>    lst<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 更改元素大小</span>    cout <span class="token operator">&lt;&lt;</span> lst<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：0</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lst<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"元素为空"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：元素为空</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="2、添加函数"><a href="#2、添加函数" class="headerlink" title="2、添加函数"></a>2、添加函数</h3><ul><li>头部添加元素：<code>push_front(const T&amp; x);</code></li><li>末尾添加元素：<code>push_back(const T&amp; x);</code></li><li>任意位置插入一个元素：<code>insert(iterator it, const T&amp; x);</code></li><li>任意位置插入 n 个相同元素：<code>insert(iterator it, int n, const T&amp; x);</code></li><li>插入另一个向量的 [forst,last] 间的数据：<code>insert(iterator it, iterator first, iterator last);</code></li></ul><p>代码示例</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 头部增加元素</span>    lst<span class="token punctuation">.</span><span class="token function">push_front</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 末尾添加元素</span>    lst<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 任意位置插入一个元素</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator it <span class="token operator">=</span> lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lst<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 任意位置插入n个相同元素</span>    lst<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 插入另一个向量的[forst,last]间的数据</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">lst2</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lst<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lst2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">++</span>lst2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历显示</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>it <span class="token operator">=</span> lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> lst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：8 9 9 9 2 4 5</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="3、删除函数"><a href="#3、删除函数" class="headerlink" title="3、删除函数"></a>3、删除函数</h3><ul><li>头部删除元素：<code>pop_front();</code></li><li>末尾删除元素：<code>pop_back();</code></li><li>任意位置删除一个元素：<code>erase(iterator it);</code></li><li>删除 [first,last] 之间的元素：<code>erase(iterator first, iterator last);</code></li><li>清空所有元素：<code>clear();</code></li></ul><p>代码示例</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        lst<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 头部删除元素</span>    lst<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 末尾删除元素</span>    lst<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 任意位置删除一个元素</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator it <span class="token operator">=</span> lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lst<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 删除[first,last]之间的元素</span>    lst<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">++</span>lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历显示</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>it <span class="token operator">=</span> lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> lst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：3 4 5 6</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 清空所有元素</span>    lst<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判断list是否为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lst<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"元素为空"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：元素为空</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4、查询函数"><a href="#4、查询函数" class="headerlink" title="4、查询函数"></a>4、查询函数</h3><ul><li>访问第一个元素：<code>front();</code></li><li>访问最后一个元素：<code>back();</code></li></ul><p>代码示例</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <list>using namespace std;int main(int argc, char* argv[]){    list<int> lst;    for (int i = 0; i < 6; i++)        lst.push_back(i);    // 访问第一个元素    cout << lst.front() << endl; // 输出：0    // 访问最后一个元素    cout << lst.back() << endl; // 输出：5    return 0;}</code></pre><h3 id="5、其他函数"><a href="#5、其他函数" class="headerlink" title="5、其他函数"></a>5、其他函数</h3><ul><li>多个元素赋值：<code>assign(int nSize, const T&amp; x); // 类似于初始化时用数组进行赋值</code></li><li>交换两个同类型容器的元素：<code>swap(list&amp;, list&amp;); 或 swap(list&amp;);</code></li><li>合并两个列表的元素（默认升序排列）：<code>merge();</code></li><li>在任意位置拼接入另一个list：<code>splice(iterator it, list&amp;);</code></li><li>删除容器中相邻的重复元素：<code>unique();</code></li></ul><p>代码示例</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 多个元素赋值s</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst1<span class="token punctuation">;</span>    lst1<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst2<span class="token punctuation">;</span>    lst2<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 交换两个容器的元素</span>    <span class="token comment" spellcheck="true">// swap(lst1, lst2); // ok</span>    lst1<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>lst2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历显示</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"交换后的lst1: "</span><span class="token punctuation">;</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator it<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>it <span class="token operator">=</span> lst1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">!=</span>lst1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：2 2 2</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历显示</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"交换后的lst2: "</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>it <span class="token operator">=</span> lst2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> lst2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：1 1 1</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst3<span class="token punctuation">;</span>    lst3<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst4<span class="token punctuation">;</span>    lst4<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 合并两个列表的元素</span>    lst4<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>lst3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不是简单的拼接，而是会升序排列</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"合并后的lst4: "</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>it <span class="token operator">=</span> lst4<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> lst4<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：3 3 3 4 4 4</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst5<span class="token punctuation">;</span>    lst5<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst6<span class="token punctuation">;</span>    lst6<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 在lst6的第2个元素处，拼接入lst5</span>    lst6<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token operator">++</span>lst6<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lst5<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"拼接后的lst6: "</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>it <span class="token operator">=</span> lst6<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> lst6<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：6 5 5 5 6 6</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 删除容器中相邻的重复元素</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst7<span class="token punctuation">;</span>    lst7<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lst7<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lst7<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lst7<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lst7<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lst7<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lst7<span class="token punctuation">.</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"删除容器中相邻的重复元素后的lst7: "</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>it <span class="token operator">=</span> lst7<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> lst7<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it<span class="token operator">++</span><span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：1 2 3 2</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><table><thead><tr><th>函数</th><th align="center">描述</th></tr></thead><tbody><tr><td>void l.assign (int n, const val)void l.assign (it first, it last)</td><td align="center">将链表l初始化为n个相同的val元素。将链表l初始化为从first到last指针所指向的这一段区域内的元素。It指针同l是一个类型的。方便将另一个链表中的某一段连续的元素copy到新链表。</td></tr><tr><td>reference l.back ()</td><td align="center">返回最后一个元素。经测试，可以直接l.back()=元素。</td></tr><tr><td>It l.begin()</td><td align="center">返回第1个元素的地址。</td></tr><tr><td>Void l.clear()</td><td align="center">清空链表。</td></tr><tr><td>bool l.empty()</td><td align="center">判断链表中是否有元素，若有，返回true。</td></tr><tr><td>It l.end()</td><td align="center">返回最后一个元素的下一个元素的地址，即此地址没有实际元素。</td></tr><tr><td>it l.erase (it pos);it l.erase (it first, it last);</td><td align="center">删除链表中it指针所指向的元素，返回被删元素的下一个元素地址。删除从first到last这一段的所有元素，返回最后一个被删元素的下一个元素地址。</td></tr><tr><td>reference l.front ()</td><td align="center">返回第一个元素。假如a=l.front()，那么a只是一个备份，对a修改不影响链表。</td></tr><tr><td>get_allocator()</td><td align="center">返回链表的配置器。</td></tr><tr><td>it l.insert (it pos, 元素类型val)void l.insert (it pos, int n,元素类型 val)void l.insert (it pos, it first, it last)</td><td align="center">在pos的前一位置插入val元素，返回该元素的地址。Val元素是不会被修改的，只是拷贝。在pos的前一位置插入n个val元素。在pos的前一位置插入first到last之间的一段元素。可以是自己或其他链表中的。</td></tr><tr><td>int l.max_size()</td><td align="center">返回链表可装入的元素数量上限，一般数字很大。经测，数字已包含了链表中存在的元素。</td></tr><tr><td>void l.merge (list&amp; x)void l.merge (list&amp; x, Compare comp)</td><td align="center">将链表x接在l之后，合并为一个链表l，合并完后链表x中的元素为0了，但x仍存在。（不排序）将两链表合并在一起，按照comp函数的排序规则来排序。</td></tr><tr><td>list&amp; l.operator= (const list&amp; x)</td><td align="center">将整个链表x中所有元素赋给链表l，相当于清空链表l，再将x赋过去。不改变x的数据。注意括号内是参数x。</td></tr><tr><td>void l.pop_back()</td><td align="center">删除链表最后一个元素。</td></tr><tr><td>void l.pop_front()</td><td align="center">删除链表第一个元素。</td></tr><tr><td>void l.push_back (const value_type&amp; val)</td><td align="center">将元素val插入到链表的尾部。</td></tr><tr><td>void l.push_front (const value_type&amp; val)</td><td align="center">将元素val插入到链表的头部。</td></tr><tr><td>it l.rbegin()</td><td align="center">返回“反向链表”的第1个元素的地址。即返回链表的最后一个元素的地址。</td></tr><tr><td>void l.remove (const value_type&amp; val)</td><td align="center">删除值等于val的元素，得一模一样才能删除，估计比对的是整块内存的二进制。与erase不同。</td></tr><tr><td>void l.remove_if (Predicate pred)</td><td align="center">功能：删除元素。将链表中每个元素单独传入pred函数，只要返回的结果为true，就删除。pred不用加括号，它类似于sort里的comp。</td></tr><tr><td>it l.rend()</td><td align="center">返回“反向链表”的最后一个元素的下一个位置，这么说可能不正确，这个函数主要用于反向链表的操作。返回的是地址，该地址没有元素。</td></tr><tr><td>void l.resize (size_type n, value_type val = value_type())</td><td align="center">重新设置链表的元素个数，若大了，会插入默认元素，若少了，或者删除部分元素。标准是已存元素。</td></tr><tr><td>void l.reverse()</td><td align="center">将所有元素的顺序置为相反，比如升序变为降序。</td></tr><tr><td>int l.size()</td><td align="center">返回已存在的元素个数，如果之前刚调用过resize，那size的大小就是resize所设置的。</td></tr><tr><td>void l.sort(comp)Void l.sort()</td><td align="center">排序，按照comp函数所返回的那样，若true则不改变位置，若false则交换位置。排序，按照默认的方法排序，一般为增序，比如整数、字符串比较的是ascii码。</td></tr><tr><td>void l.splice (it pos, list&amp; x)void l.splice (it pos, list&amp; x, it i)void l.splice (it pos, list&amp; x, it first, it last)</td><td align="center">将链表x中所有的元素“剪切”到pos处，其实只是指针操作，不用赋值。将链表x中的元素i“剪切”到pos处，只是单个元素。将链表x中first到last这段元素都迁移到l中的pos处。这些操作都会在链表l中增加新元素，并在x中删除相应元素。</td></tr><tr><td>void l.swap (list&amp; x)</td><td align="center">将两个链表互换名字，元素数量可不同，但类型得相同。</td></tr><tr><td>void l.unique()void l.unique (Predicate pred)</td><td align="center">删除重复的多余元素，使每个元素唯一。相同元素的第一个都不会删。以pred函数为依据，删除重复的元素，当pred返回true时则删除其中一个。</td></tr><tr><td>bool operator== (list&lt;T,Alloc&gt;&amp; lhs,list&lt;T,Alloc&gt;&amp; rhs);bool operator!= ( list&lt;T,Alloc&gt;&amp; lhs, list&lt;T,Alloc&gt;&amp; rhs);bool operator&lt; (list&lt;T,Alloc&gt;&amp; lhs,list&lt;T,Alloc&gt;&amp; rhs);bool operator&lt;= (list&lt;T,Alloc&gt;&amp; lhs, list&lt;T,Alloc&gt;&amp; rhs);bool operator&gt; (list&lt;T,Alloc&gt;&amp; lhs, list&lt;T,Alloc&gt;&amp; rhs);bool operator&gt;= ( list&lt;T,Alloc&gt;&amp; lhs, list&lt;T,Alloc&gt;&amp; rhs);</td><td align="center">一堆不常用的符号。直接比较，比如a==b。</td></tr><tr><td>void swap (list&lt;T,Alloc&gt;&amp; x, list&lt;T,Alloc&gt;&amp; y)</td><td align="center">交换两个链表。与l.swap是一样的效果。</td></tr></tbody></table><h2 id="五、迭代器与算法"><a href="#五、迭代器与算法" class="headerlink" title="五、迭代器与算法"></a>五、迭代器与算法</h2><h3 id="1、迭代器"><a href="#1、迭代器" class="headerlink" title="1、迭代器"></a>1、迭代器</h3><ul><li>开始迭代器指针：<code>begin();</code></li><li>末尾迭代器指针：<code>end();</code> // 指向最后一个元素的下一个位置</li><li>指向常量的开始迭代器指针：<code>cbegin();</code> // 意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。</li><li>指向常量的末尾迭代器指针：<code>cend();</code></li><li>反向迭代器指针，指向最后一个元素：<code>rbegin();</code></li><li>反向迭代器指针，指向第一个元素的前一个元素：<code>rend();</code></li></ul><p>代码示例</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> lst<span class="token punctuation">;</span>    lst<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lst<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lst<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>lst<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：1</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">--</span>lst<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：3</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>lst<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：1</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">--</span>lst<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：3</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span>lst<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：3</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">--</span>lst<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：1</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="2、算法"><a href="#2、算法" class="headerlink" title="2、算法"></a>2、算法</h3><h4 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h4><pre><code>list&lt;int&gt;::iterator it;for (it = lst.begin(); it != lst.end(); it++)    cout &lt;&lt; *it &lt;&lt; endl;</code></pre><h4 id="元素翻转"><a href="#元素翻转" class="headerlink" title="元素翻转"></a>元素翻转</h4><pre><code>#include &lt;algorithm&gt;reverse(lst.begin(), lst.end());</code></pre><h4 id="元素排序"><a href="#元素排序" class="headerlink" title="元素排序"></a>元素排序</h4><pre><code>#include &lt;algorithm&gt;sort(lst.begin(), lst.end()); // 采用的是从小到大的排序// 如果想从大到小排序，可以采用先排序后反转的方式，也可以采用下面方法:// 自定义从大到小的比较器，用来改变排序方式bool Comp(const int&amp; a, const int&amp; b) {    return a &gt; b;}sort(lst.begin(), lst.end(), Comp);</code></pre><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>1、list 为双向迭代器，故不支持<code>it+=i</code>；</p><p>2、list 不支持下标访问和at方法访问。</p><h2 id="七、代码应用实例–约瑟夫问题"><a href="#七、代码应用实例–约瑟夫问题" class="headerlink" title="七、代码应用实例–约瑟夫问题"></a>七、代码应用实例–约瑟夫问题</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*约瑟夫问题是：有 n 只猴子，按顺时针方向围成一圈选大王（编号为 1~n），从第 1 号开始报数，一直数到 m，数到 m 的猴子退到圈外，剩下的猴子再接着从 1 开始报数。就这样，直到圈内只剩下一只猴子时，这个猴子就是猴王。编程求输入 n、m 后,输出最后猴王的编号。输入数据：每行是用空格分开的两个整数，第一个是 n，第二个是 m（0&lt;m, n&lt;=1 000 000）。最后一行是：0 0输出要求：对于每行输入数据（最后一行除外），输出数据也是一行，即最后猴王的编号。输入样例：6 212 48 30 0输出样例：517*/</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> monkeys<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cin <span class="token operator">>></span> n <span class="token operator">>></span> m<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        monkeys<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//清空list容器</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//将猴子的编号放入list</span>            monkeys<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">::</span>iterator it <span class="token operator">=</span> monkeys<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>monkeys<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//只要还有不止一只猴子，就要找一只猴子让其出列</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//报数</span>                <span class="token operator">++</span>it<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> monkeys<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    it <span class="token operator">=</span> monkeys<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            it <span class="token operator">=</span> monkeys<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//删除元素后，迭代器失效，</span>                                    <span class="token comment" spellcheck="true">//要重新让迭代器指向被删元素的后面</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">==</span> monkeys<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                it <span class="token operator">=</span> monkeys<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> monkeys<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//front返回第一个元素的引用</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>erase 成员函数返回被删除元素后面那个元素的迭代器。如果被删除的是最后一个元素，则返回 end()。</p><p>这个程序也可以用 vector 实现，但是执行速度要慢很多。因为 vector 的 erase 操作牵涉元素的移动，不能在常数时间内完成，所花费的时间和容器中的元素个数有关；而 list 的 erase 操作只是修改几个指针而已，可以在常数时间内完成。当 n 很大（数十万）时，两种写法在速度上会有明显区别。</p><h2 id="八、参考文献以及博客"><a href="#八、参考文献以及博客" class="headerlink" title="八、参考文献以及博客"></a>八、参考文献以及博客</h2><p>1、<a href="https://www.cnblogs.com/linuxAndMcu/p/10260627.html">https://www.cnblogs.com/linuxAndMcu/p/10260627.html</a></p><p>2、<a href="https://www.cnblogs.com/blog-yejy/p/9535840.html">https://www.cnblogs.com/blog-yejy/p/9535840.html</a></p><p>3、<a href="http://c.biancheng.net/view/351.html">http://c.biancheng.net/view/351.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL--stack</title>
      <link href="2020/100528132.html"/>
      <url>2020/100528132.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、stack的简介"><a href="#一、stack的简介" class="headerlink" title="一、stack的简介"></a>一、stack的简介</h2><p>C++ Stack（堆栈） 是一个容器类的改编，为程序员提供了堆栈的全部功能，也就是说实现了一个先进后出（FILO）的数据结构。</p><p>C++ STL 的堆栈泛化是直接通过现有的序列容器来实现的，默认使用双端队列deque的数据结构，当然，可以采用其他线性结构（vector 或 list等），只要提供堆栈的入栈、出栈、栈顶元素访问和判断是否为空的操作即可。由于堆栈的底层使用的是其他容器，因此，堆栈可看做是一种适配器，将一种容器转换为另一种容器(堆栈容器)。<br>   为了严格遵循堆栈的数据后进先出原则，stack 不提供元素的任何迭代器操作，因此，stack 容器也就不会向外部提供可用的前向或反向迭代器类型。</p><p><strong>c++ stl栈stack的头文件为</strong>: </p><pre><code>include &lt;stack&gt;</code></pre><h2 id="二、stack操作汇总"><a href="#二、stack操作汇总" class="headerlink" title="二、stack操作汇总"></a>二、stack操作汇总</h2><ul><li>top()：返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，返回值未定义。</li><li>push(const T&amp; obj)：可以将对象副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。</li><li>push(T&amp;&amp; obj)：以移动对象的方式将对象压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。</li><li>pop()：弹出栈顶元素。</li><li>size()：返回栈中元素的个数。</li><li>empty()：在栈中没有元素的情况下返回 true。</li><li>emplace()：用传入的参数调用构造函数，在栈顶生成对象。</li><li>swap(stack<t> &amp; other_stack)：将当前栈中的元素和参数中的元素交换。参数所包含元素的类型必须和当前栈的相同。对于 stack 对象有一个特例化的全局函数 swap() 可以使用。</t></li></ul><h2 id="三、stack的成员函数详解"><a href="#三、stack的成员函数详解" class="headerlink" title="三、stack的成员函数详解"></a>三、stack的成员函数详解</h2><h4 id="创建-stack-对象"><a href="#创建-stack-对象" class="headerlink" title="创建 stack 对象"></a>创建 stack 对象</h4><p>使用堆栈前，先要利用构造函数进行初始化，创建一个堆栈对象，以进行元素的入栈、出栈等操作。</p><p>（1）   stack()<br>   默认构造函数，创建一个空的 stack 对象。<br>   例如，下面一行代码使用默认的 deque 为底层容器，创建一个空的堆栈对象 s 。<br>   stack<int> s;</int></p><p> （2） stack(const stack&amp;)<br>   复制构造函数，用一个 stack 堆栈创建一个新的堆栈。<br>   例如，下面的代码利用 s1 ，创建一个以双向链表为底层容器的空堆栈对象 s2 。<br>   stack&lt;int, list<int> &gt;  s1;<br>   stack&lt;int, list<int> &gt;  s2(s1);</int></int></p><h4 id="元素入栈"><a href="#元素入栈" class="headerlink" title="元素入栈"></a>元素入栈</h4><p>   stack堆栈容器的元素入栈函数为 push 函数。由于 C++ STL 的堆栈函数是不预设大小的，因此，入栈函数就不考虑堆栈空间是否为满，均将元素压入堆栈，从而函数没有标明入栈成功与否的返回值。<br>   如下是他的使用原型：<br>   void push(const value_type&amp; x) </p><h4 id="元素出栈"><a href="#元素出栈" class="headerlink" title="元素出栈"></a>元素出栈</h4><p>   stack容器的元素出栈函数为 pop 函数，由于函数并没有判断堆栈是否为空，才进行元素的弹出，因此，需要自行判断堆栈是否为空，才可执行 pop 函数。<br>   void pop()</p><p>   下面的示例代码，将堆栈的所有元素全部出栈，这也是经常拿来清除stack中的成员</p><pre><code> stack&lt;int&gt; s; while(!s.empty()) {     s.pop();// 出栈  }</code></pre><h4 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><p>   stack容器的栈顶元素的读取函数为 pop 函数，将取出最后入栈的元素，如下是它的使用原型<br>   value_type&amp; top()</p><h4 id="堆栈非空判断"><a href="#堆栈非空判断" class="headerlink" title="堆栈非空判断"></a>堆栈非空判断</h4><p>   随着堆栈元素不断出栈，堆栈可能会出现空的情况，因此，一般需要调用 empty 函数判断是否非空，才作元素出栈和取栈顶元素的操作。<br>   bool empty()<br>   判断堆栈是否为空，返回 true 表示堆栈已空，false 表示堆栈非空。</p><h2 id="四、栈的实现原理"><a href="#四、栈的实现原理" class="headerlink" title="四、栈的实现原理"></a>四、栈的实现原理</h2><p>以某种既有容器作为底部结构，将其接口改变，使之符合“先进后出”的特性，形成一个 stack，是很容易做到的。deque 是双向开口的数据结构，若以 deque 为底部结构并封闭其头端开口，便轻而易举地形成了一个 stack。因此，STL便以 deque 作为缺省情况下的 stack 底部结构。</p><p>  由于 stack 系以底部容器完成其所有工作，而具有这种“修改某物接口，形成另一种风貌”之性质者，称为 adapter（配接器），因此 stack 往往被归类为容器配接器。</p><h2 id="五、栈的完整定义"><a href="#五、栈的完整定义" class="headerlink" title="五、栈的完整定义"></a>五、栈的完整定义</h2><pre><code>stl_stack.h// Filename:    stl_stack.h#ifndef __SGI_STL_INTERNAL_STACK_H#define __SGI_STL_INTERNAL_STACK_H__STL_BEGIN_NAMESPACE// 如果编译器不能根据前面模板参数推导出后面使用的默认参数类型,// 那么就需要手工指定, 本实作stack内部容器默认使用deque// 选用deque可以在存储空间不足时可以动态增加, 而且代价很低#ifndef __STL_LIMITED_DEFAULT_TEMPLATEStemplate &lt;class T, class Sequence = deque&lt;T&gt; &gt;#elsetemplate &lt;class T, class Sequence&gt;#endifclass stack{  // 特化的全局运算符, 提供operator==和&lt;重载则构建出所有运算符  // 其具体细节见&lt;stl_pair.h&gt;中的说明  friend bool operator== __STL_NULL_TMPL_ARGS (const stack&amp;, const stack&amp;);  friend bool operator&lt; __STL_NULL_TMPL_ARGS (const stack&amp;, const stack&amp;);public:  // 由于stack仅支持对栈顶元素的操作, 所以不定义STL要求的  // pointer, iterator, difference_type  typedef typename Sequence::value_type value_type;  typedef typename Sequence::size_type size_type;  typedef typename Sequence::reference reference;  typedef typename Sequence::const_reference const_reference;protected:  Sequence c;   // 这个是我们实际维护的容器public:  // 下面的操作完全使用内部容器的成员函数实现  // 这再次体现了STL高度的可复用性:-)  // 判断stack是否为空  bool empty() const { return c.empty(); }  // stack中元素个数  size_type size() const { return c.size(); }  // 返回栈顶元素, 注意这里返回的是引用!!!  reference top() { return c.back(); }  const_reference top() const { return c.back(); }  // 在栈顶追加新元素  void push(const value_type&amp; x) { c.push_back(x); }  // 移除栈顶元素, 注意不返回元素的引用,  // 很多初学者随机用此容器时经常误认为pop()操作同时会返回栈顶元素的引用  void pop() { c.pop_back(); }};// 判断两个stack是否相等, 就要测试其内部维护容器是否相等// x.c == y.c会调用容器重载的operator ==template &lt;class T, class Sequence&gt;bool operator==(const stack&lt;T, Sequence&gt;&amp; x, const stack&lt;T, Sequence&gt;&amp; y){  return x.c == y.c;}template &lt;class T, class Sequence&gt;bool operator&lt;(const stack&lt;T, Sequence&gt;&amp; x, const stack&lt;T, Sequence&gt;&amp; y){  return x.c &lt; y.c;}__STL_END_NAMESPACE#endif /* __SGI_STL_INTERNAL_STACK_H */// Local Variables:// mode:C++// End:</code></pre><p>stack虽然默认基于deque（双端队列）实现的，但是我们可以传入参数，使其底层以其他可以的顺序容器来实现，比如：</p><pre><code>stack&lt;int, list&lt;int&gt;&gt; stack&lt;int, vector&lt;int&gt;&gt;stack&lt;int, array&lt;int&gt;&gt;</code></pre><p>下面给出stl的stack的使用示例：</p><pre><code>// constructing stacks#include&lt;iostream&gt;       // std::cout#include&lt;stack&gt;          // std::stack#include&lt;vector&gt;         // std::vector#include&lt;deque&gt;          // std::dequeint main (){  std::deque&lt;int&gt; mydeque (3,100);          // deque with 3 elements  std::vector&lt;int&gt; myvector (2,200);        // vector with 2 elements  std::stack&lt;int&gt; first;                    // empty stack  std::stack&lt;int&gt; second (mydeque);         // stack initialized to copy of deque  std::stack&lt;int,std::vector&lt;int&gt; &gt; third;  // empty stack using vector  std::stack&lt;int,std::vector&lt;int&gt; &gt; fourth (myvector);  std::cout &lt;&lt; "size of first: " &lt;&lt; first.size() &lt;&lt; '\n';  std::cout &lt;&lt; "size of second: " &lt;&lt; second.size() &lt;&lt; '\n';  std::cout &lt;&lt; "size of third: " &lt;&lt; third.size() &lt;&lt; '\n';  std::cout &lt;&lt; "size of fourth: " &lt;&lt; fourth.size() &lt;&lt; '\n';  second.push(2);  std::cout &lt;&lt; "The element at the top of stack second is: "        &lt;&lt; second.top( ) &lt;&lt; "." &lt;&lt; std::endl;  std::cout &lt;&lt; "size of second: " &lt;&lt; second.size() &lt;&lt; '\n';  return 0;}Output:size of first: 0size of second: 3size of third: 0size of fourth: 2The element at the top of stack second is:2 .size of second: 4</code></pre><h2 id="六、stack的使用注意事项"><a href="#六、stack的使用注意事项" class="headerlink" title="六、stack的使用注意事项"></a>六、stack的使用注意事项</h2><p>1、stack的pop()以及push()都是void类型，并没有返回值</p><p>2、因为stack的pop()成员是有返回值的，并且返回值类型是_Container::reference类型，也就是stack的引用类型。</p><p>3、stack底层一般用<strong>list或deque</strong>实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时。用其他容器做底层数据结构也可是实现栈，vector、list也支持empty、size、back、push_back、pop_back操作。如果用vector在重新分配空间时需要拷贝原来空间的元素，释放原来空间。如果使用list的话，每一次push_back、pop_back都涉及空间的分配和释放。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL--vector</title>
      <link href="2020/100417570.html"/>
      <url>2020/100417570.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、vector的简介"><a href="#一、vector的简介" class="headerlink" title="一、vector的简介"></a>一、vector的简介</h3><p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。</p><p>vector是C++标准模版库(STL,Standard Template Library)中的部分内容。之所以认为是一个容器，是因为它能够像容器一样存放各种类型的对象，简单的说：vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。</p><p>使用vector容器之前必须加上<vector>头文件：#include<vector>;</vector></vector></p><p>vector属于std命名域的内容，因此需要通过命名限定：using std::vector;也可以直接使用全局的命名空间方式：using namespace std;</p><h3 id="二、容器的特性"><a href="#二、容器的特性" class="headerlink" title="二、容器的特性"></a>二、容器的特性</h3><h5 id="顺序序列"><a href="#顺序序列" class="headerlink" title="顺序序列"></a>顺序序列</h5><p>顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</p><h5 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h5><p>支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。</p><h5 id="能够感知内存分配器的（Allocator-aware）"><a href="#能够感知内存分配器的（Allocator-aware）" class="headerlink" title="能够感知内存分配器的（Allocator-aware）"></a>能够感知内存分配器的（Allocator-aware）</h5><p>容器使用一个内存分配器对象来动态地处理它的存储需求。</p><h3 id="三、基本函数实现"><a href="#三、基本函数实现" class="headerlink" title="三、基本函数实现"></a>三、基本函数实现</h3><h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h4><ul><li>vector():创建一个空vector</li><li>vector(int nSize):创建一个vector,元素个数为nSize</li><li>vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t</li><li>vector(const vector&amp;):复制构造函数</li><li>vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</li></ul><h4 id="2-插入函数"><a href="#2-插入函数" class="headerlink" title="2.插入函数"></a>2.插入函数</h4><ul><li>void push_back(const T&amp; x):向量尾部增加一个元素X</li><li>iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x</li><li>iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x</li><li>iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</li></ul><h4 id="3-删除函数"><a href="#3-删除函数" class="headerlink" title="3.删除函数"></a>3.删除函数</h4><ul><li>iterator erase(iterator it):删除向量中迭代器指向元素</li><li>iterator erase(iterator first,iterator last):删除向量中[first,last)中元素</li><li>void pop_back():删除向量中最后一个元素</li><li>void clear():清空向量中所有元素</li></ul><h4 id="4-遍历函数"><a href="#4-遍历函数" class="headerlink" title="4.遍历函数"></a>4.遍历函数</h4><ul><li>reference at(int pos):返回pos位置元素的引用</li><li>reference front():返回首元素的引用</li><li>reference back():返回尾元素的引用</li><li>iterator begin():返回向量头指针，指向第一个元素</li><li>iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置</li><li>reverse_iterator rbegin():反向迭代器，指向最后一个元素</li><li>reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</li></ul><h4 id="5-判断函数"><a href="#5-判断函数" class="headerlink" title="5.判断函数"></a>5.判断函数</h4><ul><li>bool empty() const:判断向量是否为空，若为空，则向量中无元素</li></ul><h4 id="6-大小函数"><a href="#6-大小函数" class="headerlink" title="6.大小函数"></a>6.大小函数</h4><ul><li>int size() const:返回向量中元素的个数</li><li>int capacity() const:返回当前向量所能容纳的最大元素值</li><li>int max_size() const:返回最大可允许的vector元素数量值</li></ul><h4 id="7-其他函数"><a href="#7-其他函数" class="headerlink" title="7.其他函数"></a>7.其他函数</h4><ul><li>void swap(vector&amp;):交换两个同类型向量的数据</li><li>void assign(int n,const T&amp; x):设置向量中第n个元素的值为x</li><li>void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</li></ul><h4 id="8-看着清楚"><a href="#8-看着清楚" class="headerlink" title="8.看着清楚"></a>8.看着清楚</h4><blockquote><p>1.push_back 在数组的最后添加一个数据</p><p>2.pop_back 去掉数组的最后一个数据</p><p>3.at 得到编号位置的数据</p><p>4.begin 得到数组头的指针</p><p>5.end 得到数组的最后一个单元+1的指针</p><p>6．front 得到数组头的引用</p><p>7.back 得到数组的最后一个单元的引用</p><p>8.max_size 得到vector最大可以是多大</p><p>9.capacity 当前vector分配的大小</p><p>10.size 当前使用数据的大小</p><p>11.resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</p><p>12.reserve 改变当前vecotr所分配空间的大小</p><p>13.erase 删除指针指向的数据项</p><p>14.clear 清空当前的vector</p><p>15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1)</p><p>16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1)</p><p>17.empty 判断vector是否为空</p><p>18.swap 与另一个vector交换数据</p></blockquote><h3 id="四、基本用法"><a href="#四、基本用法" class="headerlink" title="四、基本用法"></a>四、基本用法</h3><pre><code>#include &lt; vector&gt; using namespace std;</code></pre><hr><h3 id="五、简单介绍"><a href="#五、简单介绍" class="headerlink" title="五、简单介绍"></a>五、简单介绍</h3><ol><li>vector&lt;类型&gt;标识符</li><li>vector&lt;类型&gt;标识符(最大容量)</li><li>vector&lt;类型&gt;标识符(最大容量,初始所有值)</li><li>int i[5]={1,2,3,4,5}<br>vector&lt;类型&gt;vi(I,i+2);//得到i索引值为3以后的值</li><li>vector&lt; vector&lt; int&gt; &gt;v; 二维向量//这里最外的&lt;&gt;要有空格。否则在比较旧的编译器下无法通过</li></ol><h3 id="六、具体实例"><a href="#六、具体实例" class="headerlink" title="六、具体实例"></a>六、具体实例</h3><h5 id="1-push-back-elem-在尾部插入一个elem数据。"><a href="#1-push-back-elem-在尾部插入一个elem数据。" class="headerlink" title="1.push_back(elem)在尾部插入一个elem数据。"></a>1.push_back(elem)在尾部插入一个elem数据。</h5><pre><code> vector&lt;int&gt; v; v.push_back(1);</code></pre><h5 id="2-pop-back-删除末尾的数据。"><a href="#2-pop-back-删除末尾的数据。" class="headerlink" title="2.pop_back()删除末尾的数据。"></a>2.pop_back()删除末尾的数据。</h5><pre><code> vector&lt;int&gt; v; v.pop_back();</code></pre><h5 id="3-assign-beg-end-将-beg-end-一个左闭右开区间的数据赋值给调用这个函数的vector。"><a href="#3-assign-beg-end-将-beg-end-一个左闭右开区间的数据赋值给调用这个函数的vector。" class="headerlink" title="3.assign(beg,end)将[beg,end)一个左闭右开区间的数据赋值给调用这个函数的vector。"></a>3.assign(beg,end)将[beg,end)一个左闭右开区间的数据赋值给调用这个函数的vector。</h5><pre><code>vector&lt;int&gt; v1,v2;v1.push_back(10);v1.push_back(20);v2.push_back(30);v2.assign(v1.begin(),v1.end());</code></pre><h5 id="4-assign-n-elem-将n个elem的拷贝赋值给调用的vector"><a href="#4-assign-n-elem-将n个elem的拷贝赋值给调用的vector" class="headerlink" title="4.assign (n,elem)将n个elem的拷贝赋值给调用的vector"></a>4.assign (n,elem)将n个elem的拷贝赋值给调用的vector</h5><pre><code>vector&lt;int&gt; v;v.assign(5,10);//往v里放5个10</code></pre><h5 id="5-at-int-index-传回索引为index的数据-如果index越界-抛出out-of-range异常。"><a href="#5-at-int-index-传回索引为index的数据-如果index越界-抛出out-of-range异常。" class="headerlink" title="5.at(int index)传回索引为index的数据,如果index越界,抛出out_of_range异常。"></a>5.at(int index)传回索引为index的数据,如果index越界,抛出out_of_range异常。</h5><pre><code>vecto&lt;int&gt; v;cout &lt;&lt; v.at(2) &lt;&lt; endl;//打印vector中下标是2的数据</code></pre><h5 id="6-begin-返回指向第一个数据的迭代器。"><a href="#6-begin-返回指向第一个数据的迭代器。" class="headerlink" title="6.begin()返回指向第一个数据的迭代器。"></a>6.begin()返回指向第一个数据的迭代器。</h5><h5 id="end-返回指向最后一个数据之后的迭代器。"><a href="#end-返回指向最后一个数据之后的迭代器。" class="headerlink" title="end()返回指向最后一个数据之后的迭代器。"></a>end()返回指向最后一个数据之后的迭代器。</h5><pre><code>vector&lt;int&gt; v;v.push_back(1);v.push_back(2);v.push_back(3);vector&lt;int&gt;::iterator it;for(it = v.begin();it!=v.end();it++){    cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;</code></pre><h5 id="7-rbegin-返回逆向队列的第一个数据-即c容器的最后一个数据。"><a href="#7-rbegin-返回逆向队列的第一个数据-即c容器的最后一个数据。" class="headerlink" title="7.rbegin()返回逆向队列的第一个数据,即c容器的最后一个数据。"></a>7.rbegin()返回逆向队列的第一个数据,即c容器的最后一个数据。</h5><h5 id="rend-返回逆向队列的最后一个数据的下一个位置-即c容器的第一个数据再往前的一个位置。"><a href="#rend-返回逆向队列的最后一个数据的下一个位置-即c容器的第一个数据再往前的一个位置。" class="headerlink" title="rend()返回逆向队列的最后一个数据的下一个位置,即c容器的第一个数据再往前的一个位置。"></a>rend()返回逆向队列的最后一个数据的下一个位置,即c容器的第一个数据再往前的一个位置。</h5><pre><code>vector&lt;int&gt; v;v.push_back(1);v.push_back(2);v.push_back(3);vector&lt;int&gt;::reverse_iterator it;for(it = v.rbegin();it!=v.rend();it++){    cout &lt;&lt; *it &lt;&lt; "\t";}cout &lt;&lt; endl;</code></pre><h5 id="8-capacity-返回容器中数据个数-翻倍增长。"><a href="#8-capacity-返回容器中数据个数-翻倍增长。" class="headerlink" title="8.capacity()返回容器中数据个数,翻倍增长。"></a>8.capacity()返回容器中数据个数,翻倍增长。</h5><pre><code>vector&lt;int&gt; v;v.push_back(1);cout &lt;&lt; v.capacity() &lt;&lt; endl;  // 1v.push_back(2);cout &lt;&lt; v.capacity() &lt;&lt; endl;  // 2v.push_back(3);cout &lt;&lt; v.capacity() &lt;&lt; endl; // 4</code></pre><p><strong>9.使用reverse将元素翻转</strong>：</p><p>需要头文件</p><pre><code>#include&lt;algorithm&gt;</code></pre><p>reverse(vec.begin(),vec.end());<br>将元素翻转（在vector中，如果一个函数中需要两个迭代器，一般后一个都不包含）。</p><p><strong>使用sort排序：</strong></p><p>需要头文件</p><pre><code>#include&lt;algorithm&gt;</code></pre><p>sort(vec.begin(),vec.end());(默认是按升序排列,即从小到大)。</p><p>可以通过重写排序比较函数按照降序比较，如下：<br>定义排序比较函数：</p><p>bool Comp(const int &amp;a,const int &amp;b)<br>{<br>return a&gt;b;<br>}</p><p>调用时:sort(vec.begin(),vec.end(),Comp)，这样就降序排序。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>the summary of &#39;Making Smart Contracts Smarter&#39;</title>
      <link href="2020/09308489.html"/>
      <url>2020/09308489.html</url>
      
        <content type="html"><![CDATA[<h2 id="The-Summary-of-“Making-Smart-Contracts-Smarter”"><a href="#The-Summary-of-“Making-Smart-Contracts-Smarter”" class="headerlink" title="The Summary of “Making Smart Contracts Smarter”"></a>The Summary of “Making Smart Contracts Smarter”</h2><h3 id="I-introduction"><a href="#I-introduction" class="headerlink" title="I.   introduction"></a><strong>I.</strong>   <strong>introduction</strong></h3><p>This paper focuses on the topics of smart contracts and Oyente. The authors recorded several new security bugs in Ethereum smart contracts, and at the same time formalize the semantics of Ethereum smart contracts to provide solutions for the security bugs proposed in the paper. In order to find security bugs in smart contracts, the authors built a symbolic execution tool called Oyente to find potential security bugs, and introduce Oynete’s specific design. </p><h3 id="II-samrt-contracts-and-oyente"><a href="#II-samrt-contracts-and-oyente" class="headerlink" title="II.  samrt contracts  and oyente"></a><strong>II.</strong>  <strong>samrt contracts  and oyente</strong></h3><h5 id="A-Smart-Contracts-in-Ethereum"><a href="#A-Smart-Contracts-in-Ethereum" class="headerlink" title="A.  Smart Contracts in Ethereum"></a>A.  Smart Contracts in Ethereum</h5><p>Firstly, a brief introduction to the Ethereum smart contract and its execution model. The contract state consists of two main parts: private storage and the amount of virtual currency it holds. The code of the Ethereum smart contract is written in a stack-based bytecode language and executed in the EVM. Several high-level languages can be used to write the Ethereum smart contract, and then these codes will be compiled into EVM bytecode to run. In order to ensure fair compensation for the calculation workload, Ethereum pays a certain percentage of calculation fees to the Leader node. Here is an introduction to “gasLimit” and “gasPrice”, and the relationship between them.</p><h5 id="B-Security-Bugs"><a href="#B-Security-Bugs" class="headerlink" title="B.  Security Bugs"></a>B.  Security Bugs</h5><p>In this paper, it is mentioned that the infamous attack on “TheDAO” caused a loss of about $60 million to TheDAO’s investors, in order to illustrate the destructive nature of smart contracts and why smart contracts are attractive. The authors discuss four major categories of vulnerabilities in smart contracts: transaction-ordering dependence, timestamp dependence, mishandled exceptions, and reentrancy vulnerability. These vulnerabilities allow malicious miners or users to mine and make profits. Attackers can influence the execution results of smart contracts or steal funds by changing the order of transactions, modifying time stamps, calling reentrant functions, triggering processing exceptions, etc.</p><p>In order to solve the above security vulnerabilities, this paper proposes improvements to the operational semantics of Ethereum. However, to deploy these proposals, all clients in the Ethereum network must be upgraded. In order for developers to better write better contracts and users to avoid calling problematic contracts, the author provides a tool called Oyente.</p><h5 id="C-Oyente-An-Analyzer-for-Smart-Contracts"><a href="#C-Oyente-An-Analyzer-for-Smart-Contracts" class="headerlink" title="C.  Oyente: An Analyzer for Smart Contracts"></a>C.  Oyente: An Analyzer for Smart Contracts</h5><p>Based on a model of the operational semantics of the Ethereum bytecode, the authors build a verification tool called Oyente which can symbolically execute contracts and look for vulnerabilities. The authors chose symbolic execution because it allows statically path-by-path reasoning programs. Oyente is 4,00 lines of Python, and uses Z3 as the solver to decide satisfiability. </p><p>The paper depicts the architecture overview of Oyente. On the basis of symbolic execution, Oyente can output the control flow graph of the smart contract, analyze the reachable path, and detect possible abnormalities in the path according to a series of rules, and finally verify the detected abnormalities to reduce errors. Newspaper. It needs two inputs, the bytecode of the analyzed contract and the current global state of Ethereum. It answers whether there are any security issues with the contract and outputs the symbolic path in question.</p><p>It has separate modules and it can add more analysis separately. It consists of four main components, namely CFGBuilder, Explorer, CoreAnalysis and Validator. The core part is CoreAnalysis, which transforms the path of explorer just output, and only contains some paths of Ether from the beginning to the end, and performs some vulnerability verification. Using the constraint solver Z3 can reduce the false alarm rate and false alarm rate of the entire system. At present, Oyente only provides verification of three security problems, namely TOD, Timestamp dependence, and Mishandled Exceptions. </p><p>The current Oyente is not perfect. What its main purpose now is that marking potentially vulnerable contracts. For some vulnerabilities in contracts, manual analysis is needed to confirm, which means that comprehensive false positive detection will be left to the future work. </p><h5 id="D-Test-Results"><a href="#D-Test-Results" class="headerlink" title="D.  Test Results"></a>D.  Test Results</h5><p>Finally, in the benchmark test, Oyente was run with 19,366 contracts from the blockchain as of May 5, 2016 for quantitative and qualitative analysis to determine the performance of Oyente.  It needs 350 seconds on average to analyze the contract. Among them, 8,833 of the contracts have at least one security issue: 5,411 contracts (27.9%) have mishandled exceptions; 3,056 contracts (15.7%) have transaction-ordering dependencies; 83 contracts have timestamp dependencies, and 340 contracts have reentrancy vulnerabilities – one of which is the infamous “TheDAO” contract. The section 6 of the paper specifically introduces some examples of security vulnerabilities. </p><h3 id="III-conclusion"><a href="#III-conclusion" class="headerlink" title="III. conclusion"></a><strong>III.</strong> <strong>conclusion</strong></h3><p>This paper summarizes the security vulnerabilities of Ethereum smart contracts and Oyente’s design. The authors propose several security bugs in current smart contracts. In order to better detect security bugs, they also built the smart contract analyzer named Oyente. By introducing the overview of Oyente, they explained how to make smart contracts smarter. The content discussed is only for the Ethereum smart contract platform, but security vulnerabilities may also involve other open distributed application platforms. At the same time, Oyente’s project is open sourced, so that more people discover the defects of Oyente and improve the function and performance of Oyente. </p><h3 id="IV-The-original-link"><a href="#IV-The-original-link" class="headerlink" title="IV.The original link"></a>IV.The original link</h3><p>If you’re interested, you can read the original paper.</p><p><a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=8a4931d918054adfa87a9db948b45a20&amp;site=xueshu_se">点击查看原文</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式计算的概念</title>
      <link href="2020/093022851.html"/>
      <url>2020/093022851.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h1><p>​       分布式计算( Distributed computing )是一种把需要进行大量计算的工程数据分割成小块，由多台计算机分别计算，在上传运算结果后，将结果统一合并得出数据结论的科学。目前常见的分布式计算项目通常使用世界各地上千万志愿者计算机的闲置计算能力，通过互联网进行数据传输。</p><h5 id="1-何为分布式"><a href="#1-何为分布式" class="headerlink" title="1.何为分布式"></a>1.何为分布式</h5><p>分布式就是计算机的一种算法。其实可以形象的将其比喻为撒网捕鱼，渔网中的每个节点都负责着各自的自责（不能脱离渔网，要牢不可破）。</p><h5 id="2-何谓分布式存储"><a href="#2-何谓分布式存储" class="headerlink" title="2.何谓分布式存储"></a>2.<em>何谓分布式存储</em></h5><p>分布式存储技术是利用网络将数据分散地存储于多台独立的机器设备上。核心点是数据、网络、多台主机。</p><h5 id="3-分布式计算"><a href="#3-分布式计算" class="headerlink" title="3.分布式计算"></a>3.<em>分布式计算</em></h5><p>所谓分布式计算是一门计算机科学，它研究如何把一个需要非常巨大的计算能力才能解决的问题分成许多小的部分，然后把这些部分分配给许多计算机进行处理，最后把这些计算结果综合起来得到最终的结果。</p><p>明确了以上几个概念之后，我们需要将抽象的理论转变成一些可以学习的技术。那目前到底有哪一些是这个理论的实现方式呢？其实有很多关于分布式计算和存储的技术，比如Google的GFS和MapReduce，Hadoop中的hdfs和MapReduce，流式计算领域的Storm、Spark Streaming等。面对这些目不暇接的技术时，我们需要做一些权衡，到底需要给学生学习什么技术好一些呢？其实作为教学的话，往往偏向于从基础入手，那分布式最开始的时候是由Google发明的，当时互联网泡沫刚刚结束之后，Google采取了所谓的低成本之路的策略，需要将许许多多廉价的PC机串联起来，形成一个巨大的分布式主机网络。随之发表了GFS（Google File System）的论文，之后又发表了MapReduce分布式计算和BigTable的论文，这三篇论文的出现，奠定了分布式计算和存储技术的基础。至于Hadoop和HBase就是GFS、MapReduce、BigTable的开源实现。我们无法学习Google的分布式计算，但是我们可以学习开源的Hadoop分布式计算框架。这个也就是我们选择Hadoop来教学的原因。</p><pre><code>   那Hadoop如何体现了分布式存储和分布式计算的原理呢？其实就是Hadoop的内部的两个核心部件：HDFS（Hadoop Distributed File System）和MapReduce。</code></pre><p>  （1）HDFS（Hadoop Distributed File System）即Hadoop分布式文件系统，它解决了分布式存储的问题；</p><p>  （2）MapReduce即分布式计算模型，它解决了分布式计算的问题；</p><pre><code> 因此，针对分布式计算原理的课程，其主要内容就是学习Hadoop，学习Hadoop的HDFS和MapReduce以及Hadoop生态圈外围的一些组件。</code></pre><h5 id="4-分布式和集群的区别？"><a href="#4-分布式和集群的区别？" class="headerlink" title="4.分布式和集群的区别？"></a>4.<strong>分布式和集群的区别？</strong></h5><p>分布式：一个业务分拆多个子业务，部署在不同的服务器上，实现的功能是有差异的，主要用于解决高并发问题。</p><p>集群：同一个业务，部署在多个服务器上，实现相同的功能。系统在做负载均衡的时候，看看哪个服务器比较空闲，就将任务分配给哪个服务器。主要解决系统高可用的问题。</p><p>比如，一个业务可以拆分成10个子业务，每个子业务完成需要1个小时，现在将他部署到10个服务器上，那么一个小时就可以完成，10个业务就需要10个小时（分布式）。<br>现在将该业务部署到由10台服务器组成的集群服务器上，单个任务完成的时间还是10小时，但是10个任务的完成时间还是10小时（集群）。</p><h1 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h1><h5 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h5><p>云计算（cloud computing）是基于互联网的相关服务的增加、使用和交付模式，通常涉及通过互联网来提供动态易扩展且经常是虚拟化的资源。云是网络、互联网的一种比喻说法。过去在图中往往用云来表示电信网，后来也用来表示互联网和底层基础设施的抽象。因此，云计算甚至可以让你体验每秒10万亿次的运算能力，拥有这么强大的计算能力可以模拟核爆炸、预测气候变化和市场发展趋势。用户通过电脑、笔记本、手机等方式接入数据中心，按自己的需求进行运算。 对云计算的定义有多种说法。对于到底什么是云计算，至少可以找到100种解释。现阶段广为接受的是美国国家标准与技术研究院（NIST）定义：云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问， 进入可配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务），这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。</p><p>云计算（cloud computing）是分布式计算的一种，指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户。云计算早期，简单地说，就是简单的分布式计算，解决任务分发，并进行计算结果的合并。因而，云计算又称为网格计算。通过这项技术，可以在很短的时间内（几秒种）完成对数以万计的数据的处理，从而达到强大的网络服务。 </p><p>现阶段所说的云服务已经不单单是一种分布式计算，而是分布式计算、效用计算、负载均衡、并行计算、网络存储、热备份冗杂和虚拟化等计算机技术混合演进并跃升的结果。 [</p><h5 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h5><p>云计算的可贵之处在于高灵活性、可扩展性和高性比等，与传统的网络应用模式相比，其具有如下优势与特点</p><p>1、虚拟化技术。</p><p>必须强调的是，虚拟化突破了时间、空间的界限，是云计算最为显著的特点，虚拟化技术包括应用虚拟和资源虚拟两种。众所周知，物理平台与应用部署的环境在空间上是没有任何联系的，正是通过虚拟平台对相应终端操作完成数据备份、迁移和扩展等。 </p><p>2、动态可扩展。</p><p>云计算具有高效的运算能力，在原有服务器基础上增加云计算功能能够使计算速度迅速提高，最终实现动态扩展虚拟化的层次达到对应用进行扩展的目的。 </p><p>3、按需部署。</p><p>计算机包含了许多应用、程序软件等，不同的应用对应的数据资源库不同，所以用户运行不同的应用需要较强的计算能力对资源进行部署，而云计算平台能够根据用户的需求快速配备计算能力及资源。</p><p>4、灵活性高。</p><p>目前市场上大多数IT资源、软、硬件都支持虚拟化，比如存储网络、操作系统和开发软、硬件等。虚拟化要素统一放在云系统资源虚拟池当中进行管理，可见云计算的兼容性非常强，不仅可以兼容低配置机器、不同厂商的硬件产品，还能够外设获得更高性能计算。 </p><p>5、可靠性高。</p><p>倘若服务器故障也不影响计算与应用的正常运行。因为单点<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>出现故障可以通过虚拟化技术将分布在不同物理服务器上面的应用进行恢复或利用动态扩展功能部署新的服务器进行计算。 </p><p>6、性价比高。</p><p>将资源放在虚拟资源池中统一管理在一定程度上优化了物理资源，用户不再需要昂贵、存储空间大的主机，可以选择相对廉价的<a href="https://baike.baidu.com/item/PC/107">PC</a>组成云，一方面减少费用，另一方面计算性能不逊于大型主机。 </p><p>7、可扩展性。</p><p>用户可以利用应用软件的快速部署条件来更为简单快捷的将自身所需的已有业务以及新业务进行扩展。如，计算机云计算系统中出现设备的故障，对于用户来说，无论是在计算机层面上，亦或是在具体运用上均不会受到阻碍，可以利用计算机云计算具有的动态扩展功能来对其他服务器开展有效扩展。这样一来就能够确保任务得以有序完成。在对虚拟化资源进行动态扩展的情况下，同时能够高效扩展应用，提高计算机云计算的操作水平。</p><h5 id="3-服务类型"><a href="#3-服务类型" class="headerlink" title="3.服务类型"></a>3.服务类型</h5><p>通常，它的服务类型分为三类，即基础设施即服务(<a href="https://baike.baidu.com/item/IaaS/5863121">IaaS</a>)、平台即服务(<a href="https://baike.baidu.com/item/PaaS/219931">PaaS</a>)和软件即服务(<a href="https://baike.baidu.com/item/SaaS/6703273">SaaS</a>)。这3种云计算服务有时称为云计算堆栈，因为它们构建堆栈，它们位于彼此之上，以下是这三种服务的概述： </p><p>1、基础设施即服务(IaaS)</p><p>基础设施即服务是主要的服务类别之一，它向云计算提供商的个人或组织提供虚拟化计算资源，如虚拟机、存储、网络和操作系统。 </p><p>2、平台即服务(PaaS)</p><p>平台即服务是一种服务类别，为开发人员提供通过全球互联网构建应用程序和服务的平台。Paas为开发、测试和管理软件应用程序提供按需开发环境。 [6] </p><p>3、软件即服务(SaaS)</p><p>软件即服务也是其服务的一类，通过互联网提供按需软件付费应用程序，云计算提供商托管和管理软件应用程序，并允许其用户连接到应用程序并通过全球互联网访问应用程序。</p><h5 id="4-应用"><a href="#4-应用" class="headerlink" title="4.应用"></a>4.应用</h5><p>1、云物联</p><p>“物联网就是物物相连的互联网”。这有两层意思：第一，物联网的核心和基础仍然是互联网，是在互联网基础上的延伸和扩展的网络；第二，其用户端延伸和扩展到了任何物品与物品之间，进行信息交换和通信。</p><p>物联网的两种业务模式：MAI（M2M Application Integration), 内部MaaS；MaaS（M2M As A Service), MMO, Multi-Tenants(多租户模型）。</p><p>云计算：从计算中心到数据中心在物联网的初级阶段，PoP即可满足需求；在物联网高级阶段，可能出现MVNO/MMO营运商（国外已存在多年），需要虚拟化云计算技术，SOA等技术的结合实现互联网的泛在服务：TaaS （everyTHING As A Service)。</p><p>2、云安全</p><p>“云安全”通过网状的大量客户端对网络中软件行为的异常监测，获取互联网中木马、恶意程序的最新信息，推送到Server端进行自动分析和处理，再把病毒和木马的解决方案分发到每一个客户端。</p><h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><h5 id="一-什么是大数据"><a href="#一-什么是大数据" class="headerlink" title="一.什么是大数据"></a>一.什么是大数据</h5><p>大数据最直观的理解，就是数据量很大，但是多大才算是大呢？根据IDC作出的估测，数据一直以每年50%的速度增长，也就意味着数据每两年就增长一倍。 人类在近两年产生的数据相当于之前产生的全部数据量。预计到2020年，全球将总共拥有35ZB（1ZB=1024EB,1EB=1024PB,1PB=1024TB,1TB=1024GB）的数据量。</p><p>其实，大数据不仅仅在与数据量大，大数据还包含了“快速化”、“多样化”、“价值化”等多种属性。</p><p>大数据的处理速度很快，数据从生产到消耗，可用于生成决策的时间是非常短的，也就是大数据中的1秒定律（或称：秒级定律）：就是说对处理速度有要求,一般要在秒级时间范围内给出分析结果,时间太长就失去价值了.这个速度要求是大数据处理技术和传统的数据挖掘技术最大的区别。</p><p>大数据的多样化体现在大数据的数据由10%的结构化数据（存储在数据库中），90%非机构化数据组成，这和人类信息密切相关。如在企业中我们常用的Email、文档、文件，web的文本、图像、视频，以及我们日常用的微信，Twitter、Facebook、Blog等。</p><p>大数据的数据量很大，但是其价值密度也很低，例如：我们路上随处可见的视频监控，在连续不断的监控过程中，产生的大量数据其实都是没什么用的；但是如果发生事故，仅仅就几秒的数据，就会产生极高的价值。所以说尽管大数据的数据价值密度低，但是其商业价值却很高。</p><h5 id="二-大数据的影响"><a href="#二-大数据的影响" class="headerlink" title="二.大数据的影响"></a>二.大数据的影响</h5><p>《大数据时代》这本书中讲到的大数据在思维方面的影响，大数据完全颠覆了传统的思维方式。主要体现在以下三点：</p><p>​    全样而非抽样</p><p>​    效率而非精确</p><p>​    相关而非因果</p><p>现如今，你在使用淘宝购物、百度搜索等应用的时候，你就会发现，它总能给你推荐你想要看的，这是大数据决策的体现，依据大数据分析，去匹配你属于哪一类人群，而从给你推荐这一类人群喜好的东西。</p><p>大数据的新起，也让数据分析师，数据科学家，大数据工程师，数据可视化等职业成为了热门。现如今大数据已经无处不在，包括金融、汽车、零售、餐饮、电信、能源、政务、医疗、体育、娱乐等在内的社会各行各业都融入了大数据的印记。</p><h5 id="三-大数据技术"><a href="#三-大数据技术" class="headerlink" title="三.大数据技术"></a>三.大数据技术</h5><p>数据采集</p><p>​    利用ETL工具将分布的、异构数据源中的数据如关系数据、平面数据文件等，抽取到临时中间层后进行清洗、转换、集成，最后加载到数据仓库或数据集中，成为联机分析处理、数据挖掘的基础；或者也可以把实时采集的数据作为流计算系统的输入，进行实时处理分析。</p><p>​    数据存储和管理</p><p>​    利用分布式文件系统、数据仓库、关系数据库，NoSQL数据库、云数据库等，实现对结构化、半结构化和非结构化海量数据的存储和管理</p><p>​    数据处理与分析</p><p>​    利用分布式并行编程模型和计算框架，结合机器学习和数据挖掘算法，实现对海量数据的处理和分析；对分析结果进行可视化呈现，帮助人们更好的理解数据、分析数据</p><p>​    数据隐私和安全</p><p>​    从大数据中挖掘潜在的商业价值的同时，构建隐私数据保护体系和数据安全体系，有效保护个人隐私和数据安全。</p><p>大数据的核心技术主要是： 分布式存储（HDFS） 和 分布式处理(MapReduce)</p><h1 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h1><p>云计算和边缘计算是两个不同的概念，各有特点，许多人都在研究如何在云计算架构中添加边缘计算，下面来看看可行性及利弊分析。</p><p>边缘计算并非对每个物联网设备或工作负载都具有意义。人们需要了解一些边缘计算示例，以了解应该在何时何地将其作为云计算架构的一部分。</p><p>与传统的云计算架构相比，边缘计算的性能、安全性和成本优势使其越来越受欢迎，但并不总是最适用于分布式工作负载。</p><p>边缘计算是指在最终用户的电脑、手机或物联网传感器等生成和消费数据的设备上或附近处理数据的架构。这不同于传统的云计算，云计算依靠中央服务器来接收数据、处理数据并将其发送回客户端设备。而边缘计算可以减少网络等待时间，减少数据在网络上的暴露，在某些情况下，通过将处理加载到最终用户的设备来降低成本。</p><p>由于具有吸引人的优势，云计算架构师可能希望将尽可能多的工作负载推向边缘计算。但是在这样做之前，他们应该考虑每个应用程序的结构、性能要求和安全性注意事项以及其他因素。两种类型的边缘计算架构</p><p>在权衡边缘计算模型是否合适时，首先要问的问题是哪种架构可用。主要有两种类型：</p><p>设备-边缘计算，其中直接在客户端设备上处理数据。 云计算-边缘计算，其中在边缘计算硬件上处理数据，而边缘计算硬件在地理位置上比集中式云计算数据中心更靠近客户端设备。</p><p>如果客户端设备能够以统一的方式处理该处理负担，则设备-边缘计算模型可以很好地工作。可以采用台式机或笔记本电脑来处理此问题，但低功率物联网传感器可能缺少有效处理数据所需的计算和存储资源。</p><p>此外，如果企业依赖于许多不同类型的边缘设备和操作系统，所有这些设备可能具有不同的功能和配置，那么使用设备-边缘计算模型可能会很困难。</p><p>借助云计算-边缘计算模型，最终用户设备并不是塑造架构的主要因素。如果企业使用云计算-边缘计算架构，那么最终用户使用的设备类型并不重要，因为不会将数据存储或处理从中央云转移到这些设备。与其相反，企业需要将负载转移到在云计算-边缘计算运行的服务器。这些服务器通常位于比中央云更靠近最终用户的数据中心。</p><p>边缘计算的局限性</p><p>在企业决定将工作负载移至边缘计算之前，需要评估支持这些边缘计算模型是否合理。这些限制可能使企业回到传统的云计算架构。</p><p>边缘安全</p><p>边缘计算通过很大程度地减少数据传输时间来降低一些安全风险，但同时也带来了更复杂的安全挑战。</p><p>例如，如果企业在不受控制的最终用户设备上存储或处理数据，很难保证这些设备没有受到网络攻击者可能利用的漏洞的攻击。即使使用云计算-边缘计算模型来保留对边缘计算基础设施的控制，拥有更多可管理基础设施也会增加攻击面。</p><p>与保护正在处理的数据相比，保护通过网络传输的数据(可以对其进行加密)通常要容易得多。因此，边缘计算的安全性的弊端可能超过其好处。</p><p>这使得边缘计算对于具有高安全性规范的工作负载而言并非理想选择。如果企业要处理敏感数据或有特殊的合规性要求，则具有集中式服务器的标准云计算模型的风险可能会降低。</p><p>延迟要求</p><p>边缘计算可提高应用程序性能和响应能力，因为数据不必往返于云计算的数据中心进行处理。对于需要真正即时通信流的工作负载，这是一个关键优势。云计算提供商继续增加数据中心的位置，但是他们的大型数据中心设施通常位于远离人口中心的偏远位置。</p><p>大多数工作负载具有较低的延迟标准。与传统的云计算架构相比，边缘计算网络可能只会将网络响应速度提高几毫秒。对于标准应用，常规架构带来的网络延迟是可以接受的。而确保延迟改善确实值得进行权衡，尤其是在考虑了增加的成本和管理负担之后。</p><p>数据量</p><p>考虑企业的工作负载需要处理多少数据，以及边缘计算基础设施是否可以有效地处理它。如果企业的工作负载产生大量数据，则需要一个庞大的基础设施来分析和存储该数据。从管理的角度来看，它可能成本更低，并且更容易将数据移至公共云数据中心。</p><p>另一方面，如果工作负载基本上是无状态的并且不涉及大量数据，则它们往往是边缘计算的理想选择。</p><p>边缘计算实例</p><p>为了说明上面列出的取舍，以下是边缘计算何时适合和不适合的一些示例。</p><p>采用边缘计算的很好例子包括：</p><p>自动驾驶汽车。自动驾驶汽车会收集大量数据，需要实时做出决策，以确保道路上或附近的乘客和其他人的安全。延迟问题可能会导致自动驾驶汽车的响应时间延迟几毫秒，而这种情况可能会产生严重的影响。 智能恒温器。这些设备生成的数据相对较少。此外，收集的某些数据(例如人们回家的时间和调整温度)可能会影响隐私。将数据保留在边缘计算是切实可行的，可以帮助减轻安全隐患。 交通信号灯。交通信号灯具有三个特征，使其非常适合边缘计算：实时响应变化的需求;相对较低的数据输出;偶尔会失去互联网连接。</p><p>以下是一些边缘计算效果不佳的示例：</p><p>常规应用程序。很难想到需要边缘计算基础设施的性能或响应能力的常规应用程序。它可能会减少应用程序加载或响应请求所需的时间，但这种改进并不值得付出更多成本。 监控摄像系统。监控视频通常会产生大量数据。在边缘计算处理和存储数据是不切实际的，因为这将需要大型且专门的基础设施。将数据存储在集中式云计算设施成本将会低得多，也容易得多。 智能照明系统。允许用户通过互联网控制家庭或办公室中照明的系统不会生成大量数据。但是智能照明系统往往具有最小的处理能力，也没有超低延迟要求，如果打开灯具需要一两秒钟的时间，那没什么大不了的。用户可以构建用于管理这些系统的边缘基础设施，但这在大多数情况下都不值得花费更多的成本。</p><h1 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h1><p>并行计算或称平行计算是相对于串行计算来说的。它是一种一次可执行多个指令的算法，目的是提高计算速度，及通过扩大问题求解规模，解决大型而复杂的计算问题。所谓并行计算可分为时间上的并行和空间上的并行。 时间上的并行就是指<a href="https://baike.baidu.com/item/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/1119843">流水线技术</a>，而空间上的并行则是指用多个<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E5%99%A8/914419">处理器</a>并发的执行计算。</p><p>并行计算与云计算</p><p><a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97">云计算</a>是在并行计算之后产生的概念，是由并行计算发展而来， 两者在很多方面有着共性。学习并行计算对于理解<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97">云计算</a>有很大的帮助。并行计算是学习<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97">云计算</a>必须要学习的基础课程。</p><p>但并行计算不等于云计算，<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97">云计算</a>也不等同并行计算。两者区别如下。</p><p>（1）<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97">云计算</a>萌芽于并行计算</p><p><a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97">云计算</a>的萌芽应该从<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>的并行化开始，并行机的出现是人们不满足于CPU摩尔定率的增长速度，希望把多个计算机并联起来，从而获得更快的计算速度。这是一种很简单也很朴素的实现高速计算的方法，这种方法后来被证明是相当成功的。</p><p>（2）并行计算、<a href="https://baike.baidu.com/item/%E7%BD%91%E6%A0%BC%E8%AE%A1%E7%AE%97">网格计算</a>只用于特定的科学领域，专业的用户</p><p>并行计算、<a href="https://baike.baidu.com/item/%E7%BD%91%E6%A0%BC%E8%AE%A1%E7%AE%97">网格计算</a>的提出主要是为了满足科学和技术领域的专业需要，其应用领域也基本限于科学领域。传统并行<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>的使用是一个相当专业的工作，需要使用者有较高的专业素质，多数是命令行的操作，这是很多专业人士的噩梦，更不用说普通的业余级用户了。</p><p>（3）并行计算追求的高性能</p><p>在并行计算的时代，人们极力追求的是高速的计算、采用昂贵的服务器，各国不惜代价在计算速度上超越他国，因此，并行计算时代的高性能<a href="https://baike.baidu.com/item/%E6%9C%BA%E7%BE%A4">机群</a>是一个“快速消费品”，世界TOP500高性能<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>地排名不断地在刷新，一台大型机群如果在3年左右不能得到有效的利用就远远的落后了，巨额投资无法收回。</p><p>（4）<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97">云计算</a>对于单节点的计算能力要求低</p><p>而<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97">云计算</a>时代我们并不去追求使用昂贵的服务器，我们也不用去考虑TOP500的排名，云中心的计算力和存储力可随着需要逐步增加，云计算的基础架构支持这一动态增加的方式，高性能计算将在云计算时代成为“耐用消费品”。</p><h1 id="高性能计算"><a href="#高性能计算" class="headerlink" title="高性能计算"></a>高性能计算</h1><p> 高性能计算(High performance computing) 指通常使用很多处理器(作为单个机器的一部分)或者某一集群中组织的几台计算机(作为单个计算资源操作)的计算系统和环境。高性能集群上运行的应用程序一般使用并行算法，把一个大的普通问题根据一定的规则分为许多小的子问题，在集群内的不同节点上进行计算，而这些小问题的处理结果，经过处理可合并为原问题的最终结果。由于这些小问题的计算一般是可以并行完成的，从而可以缩短问题的处理时间。</p><pre><code>  高性能集群在计算过程中，各节点是协同工作的，它们分别处理大问题的一部分，并在处理中根据需要进行数据交换，各节点的处理结果都是最终结果的一部分。高性能集群的处理能力与集群的规模成正比，是集群内各节点处理能力之和，但这种集群一般没有高可用性。高性能计算的分类方法很多。这里从并行任务间的关系角度来对高性能计算分类。</code></pre><p>一、高吞吐计算(High-throughput Computing)</p><pre><code>  有一类高性能计算，可以把它分成若干可以并行的子任务，而且各个子任务彼此间没有什么关联。因为这种类型应用的一个共同特征是在海量数据上搜索某些特定模式，所以把这类计算称为高吞吐计算。所谓的Internet计算都属于这一类。按照Flynn的分类，高吞吐计算属于SIMDSingle Instruction/Multiple Data，单指令流-多数据流)的范畴。</code></pre><p>二、分布计算(Distributed Computing)</p><pre><code>  另一类计算刚好和高吞吐计算相反，它们虽然可以给分成若干并行的子任务，但是子任务间联系很紧密，需要大量的数据交换。按照Flynn的分类，分布式的高性能计算属于MIMD（Multiple Instruction/Multiple Data，多指令流-多数据流）的范畴。  有许多类型的HPC 系统，其范围从标准计算机的大型集群，到高度专用的硬件。大多数基于集群的HPC系统使用高性能网络互连，基本的网络拓扑和组织可以使用一个简单的总线拓扑。HPC系统由计算、存储、网络、集群软件四部分组成。</code></pre><p>高性能计算HPC系统技术特点是什么？</p><pre><code>  HPC系统目前主流处理器是X86处理器，操作系统是linux 系统(包括Intel、AMD、NEC、Power、PowerPC、Sparc等)、构建方式采用刀片系统，互联网络使用IB和10GE。  高性能计算HPC集群中计算节点一般 分3种: MPI节点、胖节点、GPU加速节点。双路节点称为瘦节点(MPI节点)，双路以上称为胖节点；胖节点配置大容量内存；集群中胖节点的数量要根据实际应用需求而定。  GPU英文全称Graphic Processing Unit，中文翻译为图形处理器。 在浮点运算、并行计算等部分计算方面，GPU可以提供数十倍乃至于上百倍于CPU的性能。目前GPU厂家只有三家NVIDIA GPU、AMD GPU和Intel Xeon PHI。可选择的GPU种类比较少。</code></pre><p>NVIDIA 的GPU卡分图形卡和计算卡，图形卡有NVIDA K2000与K4000，计算卡K20X/K40M/K80 。</p><p>Intel 的GPU是Intel Xeon Phi 系列，属于计算卡，主要产品有Phi 5110P 、Phi 3210P、Phi 7120P、Phi 31S1P。</p><p>AMD 的GPU是图形和计算合一，主要产品有W5000、W9100、S7000、S9000、S10000。</p><p>1、公有云（PublicClouds），“公有”反映了这类云服务并非用户所拥有，公有云是面向大众提供计算资源的服务。是由IDC服务商或第三方提供资源，如应用和存储，这些资源是在服务商的场所内部署。用户通过Internet互联网来获取这些资源的使用。公有云服务提供商有Amazon、Google和微软，以及国内的阿里云、腾讯云等。</p><p> 公有云的优势是成本低，扩展性非常好。缺点是对于云端的资源缺乏控制、保密数据的安全性、网络性能和匹配性问题。</p><p>2、私有云（PrivateClouds），私有云是企业传统数据中心的延伸和优化，能够针对各种功能提供存储容量和处理能力。“私有”更多是指此类平台属于非共享资源，而非指其安全优势。私有云是为了一个客户单独使用而构建的，所以这些数据、安全和服务质量都较公有云有着更好地保障。而私有云由于是客户独享，则用户拥有着构建云的基础设置，并可以控制在此技术设置上部署应有程序的方式。</p><p>在私有云模式中，云平台的资源为包含多个用户的单一组织专用。私有云可由该组织、第三方或两者联合拥有、管理和运营。私有云的部署场所可以是在机构内部，也可以在外部。</p><p>私有云又分为两种</p><p>内部（on-premise）私有云：也被称为内部云，由组织在自己的数据中心内构建，如下图所示。该形式在规模和资源可扩展性上有局限，但是却有利于标准化云服务管理流程和安全性。组织依然要为物理资源承担资金成本和维护成本。这种方式适合那些需要对应用、平台配置和安全机制完全控制的机构。</p><p>外部（off-premise）私有云：这种私有云部署在组织外部，由第三方机构负责管理。第三方为该组织提供专用的云环境，并保证隐私和机密性。该方案相对内部私有云成本更低，也更便于扩展业务规模。</p><p>3、混合云（hybrid cloud）在混合云模式中，云平台由两种不同模式（私有或公有）云平台组合而成。这些平台依然是独立实体，但是利用标准化或专有技术实现绑定，彼此之间能够进行数据和应用的移植（例如，在不同云平台之间的均衡）。</p><p>应用混合云模式，一个机构可以将次要的应用和数据部署到公有云上，充分利用公有云在扩展性和成本上的优势。同时将任务关键型应用和数据放在私有云中，安全性更高。</p><p>区别1：从云的建设地点划分，公有云——互联网上发布的云计算服务，搭建云的资源在提供商的场所内；私有云——企业内部（专网）发布的云服务，搭建云平台所需的资源由企业自给。</p><p>区别2：从云服务的协议开发程度划分，公有云——协议开放的云计算服务，不需要专有的客户端软件解析。所有应用都是以服务的形式提供给用户的，而不是以软件包的形式提供。私有云——比如微软的“云端（云+端）”，最终用户需要有专用的软件。</p><p>区别3：从服务对象划分，私有云——为“一个”客户单独使用而构建的，因而提供对数据、安全性和服务质量的最有效控制；该公司拥有基础设施，并可以控制在此基础设施上部署应用程序的方式；私有云可部署在企业数据中心的防火墙内，也可以将它们部署在一个安全的主机托管场所；私有云可由云提供商进行构建，通过托管模式，构筑一个公司企业数据中心内的专用云。而公有云——则是针对外部客户，通过网络方式提供可扩展的弹性服务。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 分布式计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加Gitalk评论插件</title>
      <link href="2020/093038727.html"/>
      <url>2020/093038727.html</url>
      
        <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Gitalk-评论插件"><a href="#Gitalk-评论插件" class="headerlink" title="Gitalk 评论插件"></a>Gitalk 评论插件</h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Gitalk 是一个利用 Github API,基于 Github issue 和 Preact 开发的评论插件，在 Gitalk 之前还有一个 <a href="https://github.com/imsun/gitment">gitment</a> 插件也是基于这个原理开发的,不过 gitment 已经很久没人维护了。</p><h3 id="集成-Gitalk"><a href="#集成-Gitalk" class="headerlink" title="集成 Gitalk"></a>集成 Gitalk</h3><p>需要配置下面几个参数：</p><pre class=" language-js"><code class="language-js">clientID<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`Github Application clientID`</span></span><span class="token punctuation">,</span>clientSecret<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`Github Application clientSecret`</span></span><span class="token punctuation">,</span>repo<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`Github 仓库名`</span></span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//存储你评论 issue 的 Github 仓库名（建议直接用 GitHub Page 的仓库名）</span>owner<span class="token punctuation">:</span> <span class="token string">'Github 用户名'</span><span class="token punctuation">,</span>admin<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Github 用户名'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//这个仓库的管理员，可以有多个，用数组表示，一般写自己,</span>id<span class="token punctuation">:</span> <span class="token string">'window.location.pathname'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//页面的唯一标识，gitalk 会根据这个标识自动创建的issue的标签,我们使用页面的相对路径作为标识</span></code></pre><p>当然，还有其他很多参数，有兴趣的话可以 <a href="https://github.com/gitalk/gitalk#options"> 点这里</a>。</p><p>比如我就增加了这个全屏遮罩的参数。</p><pre><code>distractionFreeMode: true,</code></pre><h3 id="创建-Github-Application"><a href="#创建-Github-Application" class="headerlink" title="创建 Github Application"></a>创建 Github Application</h3><p>Gitalk 需要一个 <strong>Github Application</strong>，<a href="https://github.com/settings/applications/new">点击这里申请</a>。</p><p>填写下面参数：</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fmm7jaib6fj30jo0gaacs.jpg"></p><p>点击创建</p><p>获取 <code>Client ID</code> 和 <code>Client Secret</code> 填入你的我们 Gitalk 参数中</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fmm7jrzff6j30lc0budhp.jpg"></p><p>当你参数都设置好，将代码推送到 Github 仓库后，没什么问题的话，当你点击进入你的博客页面后就会出现评论框了。</p><p>当你用 github 帐号登录（管理员），并且第一次加载该会比较慢，因为第一次加载会自动在你 <code>repo</code> 的仓库下创建对应 issue。</p><p>比如说这样：</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmm867n88cj30l809mjse.jpg"></p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmm8a0i0jkj30rr0ct42t.jpg"></p><h3 id="可能遇到的坑"><a href="#可能遇到的坑" class="headerlink" title="可能遇到的坑"></a>可能遇到的坑</h3><p>1、在配置好Gitalk后页面会出现</p><p><img src="https://img.gorpeln.com/blog_gittalk_003.jpeg" alt="blog_gittalk_003"></p><p>Gitalk在使用时要为每篇博文都进行一次初始化，就是需要管理员（你创建Gitalk的GitHub账号）登录一下。PS：我的GitHub账号一直处于登录状态，发布文章后，我在预览的过程就实现了初始化，感觉影响不大。</p><p>如果你实在忍不了，可以看一下大佬实现的<a href="https://draveness.me/git-comments-initialize">自动初始化</a>。</p><p>2、评论初始化404</p><p>出现这种错误是因为：</p><p>issue的标签label有长度限制！labels的最大长度限制是50个字符</p><p>在生成label的时候 id:window.location.pathname</p><p>可能会根据编码不同而导致实际id超出50个字符，就会报错404</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 评论插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统下升级cmake版本</title>
      <link href="2020/093056989.html"/>
      <url>2020/093056989.html</url>
      
        <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-问题出现"><a href="#1-问题出现" class="headerlink" title="1.问题出现"></a>1.问题出现</h3><pre><code>cmake版本太低，无法支持某些操作</code></pre><h3 id="2-查看对应的cmake版本"><a href="#2-查看对应的cmake版本" class="headerlink" title="2.查看对应的cmake版本"></a>2.查看对应的cmake版本</h3><pre><code>cmake --version</code></pre><h3 id="3-卸载过去旧的版本"><a href="#3-卸载过去旧的版本" class="headerlink" title="3.卸载过去旧的版本"></a>3.卸载过去旧的版本</h3><pre><code>sudo apt-get autoremove cmake</code></pre><h3 id="4-下载新的版本"><a href="#4-下载新的版本" class="headerlink" title="4.下载新的版本"></a>4.下载新的版本</h3><pre><code>cd ~wget https://cmake.org/files/v3.13/cmake-3.13.2.tar.gztar xvf cmake-3.13.2.tar.gzcd cmake-3.13.2</code></pre><h3 id="5-安装"><a href="#5-安装" class="headerlink" title="5.安装"></a>5.安装</h3><pre><code>./bootstrap --prefix=/usr make sudo make install</code></pre><h3 id="6-查看新的版本"><a href="#6-查看新的版本" class="headerlink" title="6.查看新的版本"></a>6.查看新的版本</h3><pre><code>cmake --version</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/092916107.html"/>
      <url>2020/092916107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
