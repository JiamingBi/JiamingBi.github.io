<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STL--set</title>
      <link href="2020/10069761.html"/>
      <url>2020/10069761.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、set-multiset的概述"><a href="#一、set-multiset的概述" class="headerlink" title="一、set/multiset的概述"></a>一、set/multiset的概述</h3><p>​        C++ STL中标准关联容器set, multiset, map, multimap内部采用的就是一种非常高效的平衡检索二叉树：红黑树，也成为RB树(Red-Black Tree)。RB树的统计性能要好于一般平衡二叉树，所以被STL选择作为了关联容器的内部结构。</p><p>​       插入删除操作时仅仅需要指针操作节点即可完成，不涉及到内存移动和拷贝，所以效率比较高。set，顾名思义是“集合”的意思，在set中元素都是唯一的，而且默认情况下会对元素自动进行升序排列，支持集合的交(set_intersection),差(set_difference) 并(set_union)，对称差(set_symmetric_difference) 等一些集合上的操作，如果需要集合中的元素允许重复那么可以使用multiset。</p><p>​      set类似于数学里面的集合，不过set的集合中不包含重复的元素，这是和vector的第一个区别，第二个区别是set内部用平衡二叉树实现，便于元素查找，而vector是使用连续内存存储，便于随机存取。</p><p> 常见的问题所在</p><p>（1）为何map和set的插入删除效率比用其他序列容器高？</p><p>大部分人说，很简单，因为对于关联容器来说，不需要做内存拷贝和内存移动。说对了，确实如此。set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。</p><p>因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点也OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。</p><p>（2）为何每次insert之后，以前保存的iterator不会失效？</p><p>iterator这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)。相对于vector来说，每一次删除和插入，指针都有可能失效，调用push_back在尾部插入也是如此。因为为了保证内部数据的连续存放，iterator指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使时push_back的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。特别时在和find等算法在一起使用的时候，牢记这个原则：不要使用过期的iterator。</p><p>（3）当数据元素增多时，set的插入和搜索速度变化如何？</p><p>如果你知道log2的关系你应该就彻底了解这个答案。在set中查找是使用二分查找，也就是说，如果有16个元素，最多需要比较4次就能找到结果，有32个元素，最多比较5次。那么有10000个呢？最多比较的次数为log10000，最多为14次，如果是20000个元素呢？最多不过15次。看见了吧，当数据量增大一倍的时候，搜索次数只不过多了1次，多了1/14的搜索时间而已。你明白这个道理后，就可以安心往里面放入元素了。<br>（4）set为什么不用hash</p><p>首先set，不像map那样是key-value对，它的key与value是相同的。关于set有两种说法，第一个是STL中的set，用的是红黑树；第二个是hash_set，底层用得是hash table。红黑树与hash table最大的不同是，红黑树是有序结构，而hash table不是。但不是说set就不能用hash，如果只是判断set中的元素是否存在，那么hash显然更合适，因为set 的访问操作时间复杂度是log(N)的，而使用hash底层实现的hash_set是近似O(1)的。然而，set应该更加被强调理解为“集合”，而集合所涉及的操作并、交、差等，即STL提供的如交集set_intersection()、并集set_union()、差集set_difference()和对称差集set_symmetric_difference()，都需要进行大量的比较工作，那么使用底层是有序结构的红黑树就十分恰当了，这也是其相对hash结构的优势所在。</p><p><strong>multiset</strong></p><ul><li>特点</li><li>数据结构：底层实现与set一样，也采用了红黑树</li><li>允许插入重复的键值，使用insert_equal机制</li><li>插入、删除操作的时间复杂度为O(log2n)</li></ul><h3 id="二、set的基本操作"><a href="#二、set的基本操作" class="headerlink" title="二、set的基本操作"></a>二、set的基本操作</h3><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>begin()</td><td>返回容器的第一个迭代器</td></tr><tr><td>end()</td><td>返回容器的最后元素的下一个迭代器</td></tr><tr><td>clear()</td><td>删除容器中的所有元素</td></tr><tr><td>empty()</td><td>判断容器是否为空</td></tr><tr><td>insert()</td><td>插入一个元素</td></tr><tr><td>erase()</td><td>删除一个元素</td></tr><tr><td>size()</td><td>返回当前容器的元素个数</td></tr><tr><td>rbegin()</td><td>返回尾元素的逆向迭代器指针</td></tr><tr><td>reverse_iterator rend()</td><td>返回首元素前一个位置的迭代器指针</td></tr><tr><td>find()</td><td>查找一个元素，不存在返回s.end()</td></tr><tr><td>lower_bound()</td><td>返回第一个大于或等于给定关键值的元素</td></tr><tr><td>upper_bound()</td><td>返回第一个大于给定关键值的元素</td></tr><tr><td>swap()</td><td>交换两个集合元素</td></tr></tbody></table><h3 id="三、set的实现原理"><a href="#三、set的实现原理" class="headerlink" title="三、set的实现原理"></a>三、set的实现原理</h3><ol><li><p>set 的 底层数据结构是 红黑树，一种高效的平衡检索二叉树</p></li><li><p>set 容器中 每一个元素就是二叉树的每一个节点，对于set容器的插入删除操作，效率都比较高，原因是因为二叉树的删除插入元素并不需要进行内存拷贝和内存移动，只是改变了指针的指向</p></li><li><p>对 set 进行插入删除操作 都不会引起iterator的失效，因为迭代器相当于一个指针指向每一个二叉树的节点，对set的插入删除并不会改变原有内存中节点的改变， 但是vector的插入删除操作一般会发生内存移动和内存拷贝，所以会发生迭代器的失效</p></li><li><p>set容器的检索速度很快，因为采用二分查找的方法</p></li></ol><h3 id="四、具体的函数使用和相关示例"><a href="#四、具体的函数使用和相关示例" class="headerlink" title="四、具体的函数使用和相关示例"></a>四、具体的函数使用和相关示例</h3><h4 id="1、set的头文件与声明"><a href="#1、set的头文件与声明" class="headerlink" title="1、set的头文件与声明"></a>1、set的头文件与声明</h4><pre class=" language-c++"><code class="language-c++">#include<set> //头文件//声明 set<类型> 名称set<int> s;set<vector<int> > s;set<set<int> > s;multiset<double> s;</code></pre><h4 id="2、set的排序"><a href="#2、set的排序" class="headerlink" title="2、set的排序"></a>2、set的排序</h4><p>set的排序和其他stl容器的操作差不多都是一致的，都需要重新定义操作符&lt;</p><p>下面是一个定义node结构体的一个实例</p><pre class=" language-c++"><code class="language-c++">struct node{    ...};set<node> s;bool operator <(const node &a,const node &b){    return a.x>b.x;}</code></pre><p>自定义比较函数</p><pre class=" language-c++"><code class="language-c++"> (1)元素不是结构体：    例：  //自定义比较函数myComp,重载“（）”操作符struct myComp{    bool operator()(const your_type &a,const your_type &b)    {        return a.data > b.data;    }}set<int,myComp>s;set<int,myComp>::iterator it;  (2)如果元素是结构体，可以直接将比较函数写在结构体内。        例：struct Info{    string name;    float score;    //重载“<”操作符，自定义排序规则    bool operator < (const Info &a) const    {        //按score从大到小排列        return a.score<score;    }}set<Info> s;set<Info>::iterator it;</code></pre><h4 id="3、set-size"><a href="#3、set-size" class="headerlink" title="3、set.size()"></a>3、set.size()</h4><p>统计set中元素个数。函数返回一个整型变量，表示set中元素个数，时间复杂度为O(1)</p><pre><code>int num=s.size();</code></pre><h4 id="4、set-empty"><a href="#4、set-empty" class="headerlink" title="4、set.empty()"></a>4、set.empty()</h4><p>检查set是否为空，返回一个bool型变量，1表示set为空，否则为非空，时间复杂度O(1)</p><pre><code>if(s.empty()){    cout&lt;&lt;"set is empty."&lt;&lt;endl;}</code></pre><h4 id="5、set-count-x"><a href="#5、set-count-x" class="headerlink" title="5、set.count(x)"></a><strong>5、set.count(x)</strong></h4><p>返回set或multiset中值为x的元素个数，时间复杂度为O(log n)</p><pre><code>if(!s.count(x))   ans++;</code></pre><h4 id="6、迭代器"><a href="#6、迭代器" class="headerlink" title="6、迭代器"></a>6、迭代器</h4><p>双向访问迭代器，不支持随机访问，支持星号解除引用，仅支持“++”，“–”这两个算术操作</p><h5 id="引用和操作"><a href="#引用和操作" class="headerlink" title="引用和操作"></a>引用和操作</h5><pre><code>set&lt;int&gt;::inerator it=s.begin();it++;it--</code></pre><p>若把it++，则it将会指向“下一个”元素。这里的下一个是指在key从小到大排序的结果中，排在it下一名的元素。同理，若把it–，则it会指向排在上一个的元素</p><p>“++”，“–”操作的复杂度均为O(log n)</p><h4 id="7、set-begin"><a href="#7、set-begin" class="headerlink" title="7、set.begin()"></a>7、set.begin()</h4><p>返回集合的首迭代器，即指向集合中最小元素的迭代器，时间复杂度为O(1)</p><pre><code>set&lt;int&gt;::inerator it=s.begin();</code></pre><h4 id="8、set-end"><a href="#8、set-end" class="headerlink" title="8、set.end()"></a>8、set.end()</h4><p>返回集合的尾迭代器，众所周知，STL中区间都是左闭右开的，那么end()函数返回的迭代器即为指向集合中最大元素的下一个位置的迭代器，因此–s.end()才是指向集合中最大元素的迭代器，时间复杂度为O(1)</p><h4 id="9、set-insert-x"><a href="#9、set-insert-x" class="headerlink" title="9、set.insert(x)"></a>9、set.insert(x)</h4><p>在set中插入元素，返回插入地址的迭代器和是否插入成功的bool并成的pair，时间复杂度为O(log n)</p><p>PS：set在进行插入的时候是不允许有重复的键值的，如果新插入的键值与原有的键值重复则插入无效（multiset可以重复）</p><h4 id="10、set-erase-参数"><a href="#10、set-erase-参数" class="headerlink" title="10、set.erase(参数)"></a>10、set.erase(参数)</h4><p>删除，参数可以是元素或者迭代器，返回下一个元素的迭代器，时间复杂度为O(log n)，注意在multiset中s.erase(x)会删除所有值为x的元素</p><pre><code>set&lt;int&gt;::inerator it=s.begin();s.erase(it);s.erase(3);</code></pre><h4 id="11、set-find-x"><a href="#11、set-find-x" class="headerlink" title="11、set.find(x)"></a>11、set.find(x)</h4><p>在set中查找值为x的元素，并返回指向该元素的迭代器，若不存在，返回set.end()，时间复杂度为O(log n)</p><pre><code>if(s.find(x)!=s.end())    cout&lt;&lt;"have found!"&lt;&lt;endl</code></pre><h4 id="12、et-lower-bound-x-upper-bound-x"><a href="#12、et-lower-bound-x-upper-bound-x" class="headerlink" title="12、et.lower_bound(x)/upper_bound(x)"></a>12、<strong>et.lower_bound(x)/upper_bound(x)</strong></h4><p>用法与find类似，但查找的条件略有不同，时间复杂度O(log n)</p><p>s.lower_bound(x)表示查找&gt;=x的元素中最小的一个，并返回指向该元素的迭代器</p><p>s.upper_bound(x)表示查找&gt;x的元素中最小的一个，并返回指向该元素的迭代器</p><p>举个例子：</p><p>在set{3,5,7,8,13,16}中</p><p>对于在set中存在的元素，比如<strong>8</strong></p><p><strong>s.lower_bound(8)返回8所在位置的迭代器。</strong></p><p><strong>s.upper_bound(8)返回13所在位置的迭代器。</strong></p><p><strong>对于在set中不存在的元素，比如12，</strong></p><p><strong>两个函数返回的则都是13所在位置的迭代器。</strong></p><p><strong>特殊地，</strong></p><p><strong>对于比set中最大的元素大的元素，比如20，</strong></p><p><strong>两个函数返回的都是s.end()。</strong></p><h4 id="13、set-lt-pair-lt-int-int-gt-gt-的用法"><a href="#13、set-lt-pair-lt-int-int-gt-gt-的用法" class="headerlink" title="13、set<pair<int,int> >的用法"></a>13、set&lt;pair&lt;int,int&gt; &gt;的用法</h4><p>set默认的比较规则先按照first比较，如果first相同，再按照second 比较。 注意：定义的时候右边的两个&gt;&gt;要空一格。</p><pre class=" language-c++"><code class="language-c++">#include <bits/stdc++.h>  //万能头文件using namespace std;#define INF 0x3f3f3f3fint main(){  set<pair<int,int> > s;  s.insert(make_pair(3,1));  s.insert(make_pair(3,2));  s.insert(make_pair(1,1));  s.insert(make_pair(1,2));  s.insert(make_pair(2,5));  s.insert(make_pair(2,4));  set<pair<int ,int> > ::iterator it;  for(it=s.begin();it!=s.end();it++)    cout<<it->first<<' '<<it->second<<"\n";  it=s.upper_bound(make_pair(2,4));  if(it!=s.end())    printf("(2,4)后面接着是%d %d\n",it->first,it->second);}</code></pre><h3 id="五、使用set需要注意的事项"><a href="#五、使用set需要注意的事项" class="headerlink" title="五、使用set需要注意的事项"></a>五、使用set需要注意的事项</h3><p>set（集合）——<strong>包含了经过排序了的数据，这些数据的值(value)必须是唯一的。</strong></p><p>set基于<code>红黑树</code>实现，红黑树具有<code>自动排序</code>的功能，因此map内部所有的数据，在任何时候，都是有序的。<code>unordered_set基于哈希表</code>，数据插入和查找的时间复杂度很低，几乎是常数时间，而代价是消耗比较多的内存，<code>无自动排序功能</code>。底层实现上，使用一个下标范围比较大的数组来存储元素，形成很多的桶，利用hash函数对key进行映射到不同区域进行保存。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL--list</title>
      <link href="2020/100655331.html"/>
      <url>2020/100655331.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、list的概述"><a href="#一、list的概述" class="headerlink" title="一、list的概述"></a>一、list的概述</h2><p>list 由双向链表（doubly linked list）实现而成，元素也存放在堆中，每个元素都是放在一块内存中，他的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随机存取变得非常没有效率，因此它没有提供 [] 操作符的重载。但是由于链表的特点，它可以很有效率的支持任意地方的插入和删除操作。</p><p>stl_list其中的增删改查的细节实现本质是一样的，都是处理指针偏移。相比于vector，stl_List在插入和删除的时候可以达到O(1)的时间复杂度。</p><p>stl_list是一个双向循环链表，相对单链表来说查找效率高，无论是插入时的前插和后插，还是从后往前查找某个元素等。既然查找效率高了，自然添加，删除和修改元素时效率也就更高。唯一一个可以称为不足的就是每个节点需要耗费4字节指针来保存前一个节点的地址，因此如果遇到对内存要求比较苛刻的场景，而且一些操作单链表即可满足，那么可以考虑使用标准库中的forward_list（单链表）。</p><h2 id="二、定义和初始化"><a href="#二、定义和初始化" class="headerlink" title="二、定义和初始化"></a>二、定义和初始化</h2><p>使用之前必须加相应容器的头文件：</p><pre class=" language-c++"><code class="language-c++">#include <list> // list属于std命名域的，因此需要通过命名限定，例如using std::list;</code></pre><p>定义的代码如下：</p><pre class=" language-c++"><code class="language-c++">list<int> a; // 定义一个int类型的列表alist<int> a(10); // 定义一个int类型的列表a，并设置初始大小为10list<int> a(10, 1); // 定义一个int类型的列表a，并设置初始大小为10且初始值都为1list<int> b(a); // 定义并用列表a初始化列表bdeque<int> b(a.begin(), ++a.end()); // 将列表a中的第1个元素作为列表b的初始值</code></pre><p>除此之外，还可以直接使用数组来初始化向量：</p><pre class=" language-c++"><code class="language-c++">int n[] = { 1, 2, 3, 4, 5 };list<int> a(n, n + 5); // 将数组n的前5个元素作为列表a的初值</code></pre><h2 id="三、list的实现原理"><a href="#三、list的实现原理" class="headerlink" title="三、list的实现原理"></a>三、list的实现原理</h2><pre class=" language-c++"><code class="language-c++">#include "stl_def.h"/** @file stl_list.h *  *  This is an stl_list header file, implement double loop list warppes   *  *  Created by yejy on 18-8-18 *  copyright (c) yejy. all rights reserved *  */__YAMI_BEGIN/* stl list  allocate 直接使用默认new/delete */template <typename T>class list{public:  // 不包数据实体，只包含指针和相关操作, 可以认为是节省一个指针大小的内存  struct list_node_base    {    list_node_base* Next;    list_node_base* Prev;    list_node_base():Next(nullptr), Prev(nullptr){}  };  // dataEntry node  struct list_node: public list_node_base  {      T dataEntry;  };  // 迭代器 iterator  struct list_iterator  {    typedef list_iterator   _Self;    typedef T               value_type;    typedef T*              pointer;    typedef T&              reference;    list_iterator() _T_STD_NOEXCEPT    {      m_smartPtr = nullptr;    }    explicit list_iterator(list_node_base * pNode) _T_STD_NOEXCEPT    {      m_smartPtr = pNode;    }    reference operator*() _T_STD_NOEXCEPT    {      return  static_cast<list_node *>(m_smartPtr)->dataEntry;    }    list_node_base* operator->() _T_STD_NOEXCEPT    {      return m_smartPtr;    }    _Self operator++(int) _T_STD_NOEXCEPT // 后 ++    {      _Self __tmp = *this;      m_smartPtr = m_smartPtr->Next;      return __tmp;    }    _Self& operator++() _T_STD_NOEXCEPT // 前 ++    {      m_smartPtr = m_smartPtr->Next;      return *this;    }    _Self operator--(int) _T_STD_NOEXCEPT    {      _Self __tmp = *this;      m_smartPtr = m_smartPtr->Prev;      return __tmp;    }    _Self& operator--() _T_STD_NOEXCEPT    {      m_smartPtr = m_smartPtr->Prev;      return *this;    }    bool operator==(const list_iterator & _Right) const _T_STD_NOEXCEPT    {      return m_smartPtr == _Right.m_smartPtr;    }    bool operator!=(const list_iterator & _Right) const _T_STD_NOEXCEPT    {       return m_smartPtr != _Right.m_smartPtr;    }    list_node_base * m_smartPtr; // 节点指针  };public:  typedef list_iterator iterator;public:  list()  // 默认构造  {     empty_init();  }  list(const list<T> & rhs) // 拷贝构造  {    if(this != &rhs)    {      empty_init(); // 初始化      iterator itrBegin = rhs.begin();      iterator itrEnd = rhs.end();      while(itrBegin != itrEnd)      {         list_node * tmp = static_cast<list_node *>(itrBegin.m_smartPtr);         push_back(tmp->dataEntry);         ++itrBegin;      }    }  }  list & operator = (const list<T> & rhs) // 赋值运算符重载  {    if(this != &rhs)    {      // 如果原来链表有值，则先清空      if(begin() != end())      {        clear();      }      iterator itrBegin = rhs.begin();      iterator itrEnd = rhs.end();      while(itrBegin != itrEnd)      {         list_node * tmp = static_cast<list_node *>(itrBegin.m_smartPtr);         push_back(tmp->dataEntry);         ++itrBegin;      }    }  }  ~list()  {    clear();    if(pHeadNode)    {      delete pHeadNode;      pHeadNode = nullptr;    }  }  iterator begin() _T_STD_NOEXCEPT  {    return iterator(pHeadNode->Next);  }  iterator end() _T_STD_NOEXCEPT  {    return iterator(pHeadNode);  }  void push_back(const T & value)  {    insert(end(), value);  }  void push_front(const T & value)  {    insert(begin(), value);  }  void pop_front()   {     erase(begin());   }  void pop_back()   {     iterator tmp = end();    erase(--tmp);  }  T & front()  {    return *begin();  }  T & back()  {    return *(--end());  }  unsigned int remove(const T & value)  {    unsigned int count = 0;    iterator itrBegin = begin();    while(itrBegin != end())    {      if(*itrBegin == value)      {        itrBegin = erase(itrBegin);        ++count;      }      else      {        ++itrBegin;      }    }    return count;  }  iterator erase(iterator position)  {    list_node_base* next_node = position.m_smartPtr->Next;    list_node_base* prev_node = position.m_smartPtr->Prev;    prev_node->Next = next_node;    next_node->Prev = prev_node;    delete position.m_smartPtr;    position.m_smartPtr = nullptr;    if(_size > 0)    {      _size--;    }    return iterator(next_node);  }  iterator insert(iterator position, const T& x)   {    list_node* tmp = new list_node();    tmp->dataEntry = x;    tmp->Next = position.m_smartPtr;    tmp->Prev = position.m_smartPtr->Prev;    position.m_smartPtr->Prev->Next = tmp;    position.m_smartPtr->Prev = tmp;    ++_size;    return iterator(tmp);  }  void clear()  {    iterator itrBegin = begin();    while(itrBegin != end())    {      list_node* tmp =  static_cast<list_node *>(itrBegin.m_smartPtr);      ++itrBegin;      if(tmp)      {        delete tmp; // 差点犯了一个错误，delete会对用析构函数，并且释放内存。 需要析构子类还是父类，一定要传入正确类型      }    }    pHeadNode->Next = pHeadNode;    pHeadNode->Prev = pHeadNode;    _size = 0;  }  int size()  {    return _size;  }private:  void empty_init()   {     pHeadNode = new list_node_base();    pHeadNode->Next = pHeadNode;  // 初始化指针指向自己    pHeadNode->Prev = pHeadNode;    _size = 0;  }private:  list_node_base* pHeadNode; // 链表头  unsigned int _size; // 链表个数，提高查找效率，如果想为了节省内存，可以不要，临时查找};__YAMI_END</code></pre><p>如果想具体看源码的实现，下面提供一个github的源代码</p><p><a href="https://github.com/Yejy813/stl_implement">stl_implement</a></p><h2 id="四、基本函数"><a href="#四、基本函数" class="headerlink" title="四、基本函数"></a>四、基本函数</h2><h3 id="1、容量函数"><a href="#1、容量函数" class="headerlink" title="1、容量函数"></a>1、容量函数</h3><ul><li>容器大小：size();</li><li>容器最大容量：max_size();</li><li>更改容器大小：resize();</li><li>容器判空：empty();</li></ul><p>代码示例</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <list>using namespace std;int main(int argc, char* argv[]){    list<int> lst;    for (int i = 0; i<6; i++)    {        lst.push_back(i);    }    cout << lst.size() << endl; // 输出：6    cout << lst.max_size() << endl; // 输出：357913941    lst.resize(0); // 更改元素大小    cout << lst.size() << endl; // 输出：0    if (lst.empty())        cout << "元素为空" << endl; // 输出：元素为空    return 0;}</code></pre><h3 id="2、添加函数"><a href="#2、添加函数" class="headerlink" title="2、添加函数"></a>2、添加函数</h3><ul><li>头部添加元素：<code>push_front(const T&amp; x);</code></li><li>末尾添加元素：<code>push_back(const T&amp; x);</code></li><li>任意位置插入一个元素：<code>insert(iterator it, const T&amp; x);</code></li><li>任意位置插入 n 个相同元素：<code>insert(iterator it, int n, const T&amp; x);</code></li><li>插入另一个向量的 [forst,last] 间的数据：<code>insert(iterator it, iterator first, iterator last);</code></li></ul><p>代码示例</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <list>using namespace std;int main(int argc, char* argv[]){    list<int> lst;    // 头部增加元素    lst.push_front(4);    // 末尾添加元素    lst.push_back(5);    // 任意位置插入一个元素    list<int>::iterator it = lst.begin();    lst.insert(it, 2);    // 任意位置插入n个相同元素    lst.insert(lst.begin(), 3, 9);    // 插入另一个向量的[forst,last]间的数据    list<int> lst2(5, 8);    lst.insert(lst.begin(), lst2.begin(), ++lst2.begin());    // 遍历显示    for (it = lst.begin(); it != lst.end(); it++)        cout << *it << " "; // 输出：8 9 9 9 2 4 5    cout << endl;    return 0;}</code></pre><h3 id="3、删除函数"><a href="#3、删除函数" class="headerlink" title="3、删除函数"></a>3、删除函数</h3><ul><li>头部删除元素：<code>pop_front();</code></li><li>末尾删除元素：<code>pop_back();</code></li><li>任意位置删除一个元素：<code>erase(iterator it);</code></li><li>删除 [first,last] 之间的元素：<code>erase(iterator first, iterator last);</code></li><li>清空所有元素：<code>clear();</code></li></ul><p>代码示例</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <list>using namespace std;int main(int argc, char* argv[]){    list<int> lst;    for (int i = 0; i < 8; i++)        lst.push_back(i);    // 头部删除元素    lst.pop_front();    // 末尾删除元素    lst.pop_back();    // 任意位置删除一个元素    list<int>::iterator it = lst.begin();    lst.erase(it);    // 删除[first,last]之间的元素    lst.erase(lst.begin(), ++lst.begin());    // 遍历显示    for (it = lst.begin(); it != lst.end(); it++)        cout << *it << " "; // 输出：3 4 5 6    cout << endl;    // 清空所有元素    lst.clear();    // 判断list是否为空    if (lst.empty())    cout << "元素为空" << endl; // 输出：元素为空    return 0;}</code></pre><h3 id="4、查询函数"><a href="#4、查询函数" class="headerlink" title="4、查询函数"></a>4、查询函数</h3><ul><li>访问第一个元素：<code>front();</code></li><li>访问最后一个元素：<code>back();</code></li></ul><p>代码示例</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <list>using namespace std;int main(int argc, char* argv[]){    list<int> lst;    for (int i = 0; i < 6; i++)        lst.push_back(i);    // 访问第一个元素    cout << lst.front() << endl; // 输出：0    // 访问最后一个元素    cout << lst.back() << endl; // 输出：5    return 0;}</code></pre><h3 id="5、其他函数"><a href="#5、其他函数" class="headerlink" title="5、其他函数"></a>5、其他函数</h3><ul><li>多个元素赋值：<code>assign(int nSize, const T&amp; x); // 类似于初始化时用数组进行赋值</code></li><li>交换两个同类型容器的元素：<code>swap(list&amp;, list&amp;); 或 swap(list&amp;);</code></li><li>合并两个列表的元素（默认升序排列）：<code>merge();</code></li><li>在任意位置拼接入另一个list：<code>splice(iterator it, list&amp;);</code></li><li>删除容器中相邻的重复元素：<code>unique();</code></li></ul><p>代码示例</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <list>using namespace std;int main(int argc, char* argv[]){    // 多个元素赋值s    list<int> lst1;    lst1.assign(3, 1);    list<int> lst2;    lst2.assign(3, 2);    // 交换两个容器的元素    // swap(lst1, lst2); // ok    lst1.swap(lst2);    // 遍历显示    cout << "交换后的lst1: ";    list<int>::iterator it;    for (it = lst1.begin(); it!=lst1.end(); it++)        cout << *it << " "; // 输出：2 2 2    cout << endl;    // 遍历显示    cout << "交换后的lst2: ";    for (it = lst2.begin(); it != lst2.end(); it++)        cout << *it << " "; // 输出：1 1 1    cout << endl;    list<int> lst3;    lst3.assign(3, 3);    list<int> lst4;    lst4.assign(3, 4);    // 合并两个列表的元素    lst4.merge(lst3); // 不是简单的拼接，而是会升序排列    cout << "合并后的lst4: ";    for (it = lst4.begin(); it != lst4.end(); it++)        cout << *it << " "; // 输出：3 3 3 4 4 4    cout << endl;    list<int> lst5;    lst5.assign(3, 5);    list<int> lst6;    lst6.assign(3, 6);    // 在lst6的第2个元素处，拼接入lst5    lst6.splice(++lst6.begin(), lst5);    cout << "拼接后的lst6: ";    for (it = lst6.begin(); it != lst6.end(); it++)        cout << *it << " "; // 输出：6 5 5 5 6 6    cout << endl;    // 删除容器中相邻的重复元素    list<int> lst7;    lst7.push_back(1);    lst7.push_back(1);    lst7.push_back(2);    lst7.push_back(2);    lst7.push_back(3);    lst7.push_back(2);    lst7.unique();    cout << "删除容器中相邻的重复元素后的lst7: ";    for (it = lst7.begin(); it != lst7.end(); it++)        cout << *it << " "; // 输出：1 2 3 2    cout << endl;    return 0;}</code></pre><table><thead><tr><th>函数</th><th align="center">描述</th></tr></thead><tbody><tr><td>void l.assign (int n, const val)void l.assign (it first, it last)</td><td align="center">将链表l初始化为n个相同的val元素。将链表l初始化为从first到last指针所指向的这一段区域内的元素。It指针同l是一个类型的。方便将另一个链表中的某一段连续的元素copy到新链表。</td></tr><tr><td>reference l.back ()</td><td align="center">返回最后一个元素。经测试，可以直接l.back()=元素。</td></tr><tr><td>It l.begin()</td><td align="center">返回第1个元素的地址。</td></tr><tr><td>Void l.clear()</td><td align="center">清空链表。</td></tr><tr><td>bool l.empty()</td><td align="center">判断链表中是否有元素，若有，返回true。</td></tr><tr><td>It l.end()</td><td align="center">返回最后一个元素的下一个元素的地址，即此地址没有实际元素。</td></tr><tr><td>it l.erase (it pos);it l.erase (it first, it last);</td><td align="center">删除链表中it指针所指向的元素，返回被删元素的下一个元素地址。删除从first到last这一段的所有元素，返回最后一个被删元素的下一个元素地址。</td></tr><tr><td>reference l.front ()</td><td align="center">返回第一个元素。假如a=l.front()，那么a只是一个备份，对a修改不影响链表。</td></tr><tr><td>get_allocator()</td><td align="center">一直不知道此物何用？</td></tr><tr><td>it l.insert (it pos, 元素类型val)void l.insert (it pos, int n,元素类型 val)void l.insert (it pos, it first, it last)</td><td align="center">在pos的前一位置插入val元素，返回该元素的地址。Val元素是不会被修改的，只是拷贝。在pos的前一位置插入n个val元素。在pos的前一位置插入first到last之间的一段元素。可以是自己或其他链表中的。</td></tr><tr><td>int l.max_size()</td><td align="center">返回链表可装入的元素数量上限，一般数字很大。经测，数字已包含了链表中存在的元素。</td></tr><tr><td>void l.merge (list&amp; x)void l.merge (list&amp; x, Compare comp)</td><td align="center">将链表x接在l之后，合并为一个链表l，合并完后链表x中的元素为0了，但x仍存在。（不排序）将两链表合并在一起，按照comp函数的排序规则来排序。</td></tr><tr><td>list&amp; l.operator= (const list&amp; x)</td><td align="center">将整个链表x中所有元素赋给链表l，相当于清空链表l，再将x赋过去。不改变x的数据。注意括号内是参数x。</td></tr><tr><td>void l.pop_back()</td><td align="center">删除链表最后一个元素。</td></tr><tr><td>void l.pop_front()</td><td align="center">删除链表第一个元素。</td></tr><tr><td>void l.push_back (const value_type&amp; val)</td><td align="center">将元素val插入到链表的尾部。</td></tr><tr><td>void l.push_front (const value_type&amp; val)</td><td align="center">将元素val插入到链表的头部。</td></tr><tr><td>it l.rbegin()</td><td align="center">返回“反向链表”的第1个元素的地址。即返回链表的最后一个元素的地址。</td></tr><tr><td>void l.remove (const value_type&amp; val)</td><td align="center">删除值等于val的元素，得一模一样才能删除，估计比对的是整块内存的二进制。与erase不同。</td></tr><tr><td>void l.remove_if (Predicate pred)</td><td align="center">功能：删除元素。将链表中每个元素单独传入pred函数，只要返回的结果为true，就删除。pred不用加括号，它类似于sort里的comp。</td></tr><tr><td>it l.rend()</td><td align="center">返回“反向链表”的最后一个元素的下一个位置，这么说可能不正确，这个函数主要用于反向链表的操作。返回的是地址，该地址没有元素。</td></tr><tr><td>void l.resize (size_type n, value_type val = value_type())</td><td align="center">重新设置链表的元素个数，若大了，会插入默认元素，若少了，或者删除部分元素。标准是已存元素。</td></tr><tr><td>void l.reverse()</td><td align="center">将所有元素的顺序置为相反，比如升序变为降序。</td></tr><tr><td>int l.size()</td><td align="center">返回已存在的元素个数，如果之前刚调用过resize，那size的大小就是resize所设置的。</td></tr><tr><td>void l.sort(comp)Void l.sort()</td><td align="center">排序，按照comp函数所返回的那样，若true则不改变位置，若false则交换位置。排序，按照默认的方法排序，一般为增序，比如整数、字符串比较的是ascii码。</td></tr><tr><td>void l.splice (it pos, list&amp; x)void l.splice (it pos, list&amp; x, it i)void l.splice (it pos, list&amp; x, it first, it last)</td><td align="center">将链表x中所有的元素“剪切”到pos处，其实只是指针操作，不用赋值。将链表x中的元素i“剪切”到pos处，只是单个元素。将链表x中first到last这段元素都迁移到l中的pos处。这些操作都会在链表l中增加新元素，并在x中删除相应元素。</td></tr><tr><td>void l.swap (list&amp; x)</td><td align="center">将两个链表互换名字，元素数量可不同，但类型得相同。</td></tr><tr><td>void l.unique()void l.unique (Predicate pred)</td><td align="center">删除重复的多余元素，使每个元素唯一。相同元素的第一个都不会删。以pred函数为依据，删除重复的元素，当pred返回true时则删除其中一个。</td></tr><tr><td>bool operator== (list&lt;T,Alloc&gt;&amp; lhs,list&lt;T,Alloc&gt;&amp; rhs);bool operator!= ( list&lt;T,Alloc&gt;&amp; lhs, list&lt;T,Alloc&gt;&amp; rhs);bool operator&lt; (list&lt;T,Alloc&gt;&amp; lhs,list&lt;T,Alloc&gt;&amp; rhs);bool operator&lt;= (list&lt;T,Alloc&gt;&amp; lhs, list&lt;T,Alloc&gt;&amp; rhs);bool operator&gt; (list&lt;T,Alloc&gt;&amp; lhs, list&lt;T,Alloc&gt;&amp; rhs);bool operator&gt;= ( list&lt;T,Alloc&gt;&amp; lhs, list&lt;T,Alloc&gt;&amp; rhs);</td><td align="center">一堆不常用的符号。直接比较，比如a==b。</td></tr><tr><td>void swap (list&lt;T,Alloc&gt;&amp; x, list&lt;T,Alloc&gt;&amp; y)</td><td align="center">交换两个链表。与l.swap是一样的效果。</td></tr></tbody></table><h2 id="五、迭代器与算法"><a href="#五、迭代器与算法" class="headerlink" title="五、迭代器与算法"></a>五、迭代器与算法</h2><h3 id="1、迭代器"><a href="#1、迭代器" class="headerlink" title="1、迭代器"></a>1、迭代器</h3><ul><li>开始迭代器指针：<code>begin();</code></li><li>末尾迭代器指针：<code>end();</code> // 指向最后一个元素的下一个位置</li><li>指向常量的开始迭代器指针：<code>cbegin();</code> // 意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。</li><li>指向常量的末尾迭代器指针：<code>cend();</code></li><li>反向迭代器指针，指向最后一个元素：<code>rbegin();</code></li><li>反向迭代器指针，指向第一个元素的前一个元素：<code>rend();</code></li></ul><p>代码示例</p><pre class=" language-c++"><code class="language-c++">#include <iostream>#include <list>using namespace std;int main(int argc, char* argv[]){    list<int> lst;    lst.push_back(1);    lst.push_back(2);    lst.push_back(3);    cout << *(lst.begin()) << endl; // 输出：1    cout << *(--lst.end()) << endl; // 输出：3    cout << *(lst.cbegin()) << endl; // 输出：1    cout << *(--lst.cend()) << endl; // 输出：3    cout << *(lst.rbegin()) << endl; // 输出：3    cout << *(--lst.rend()) << endl; // 输出：1    cout << endl;    return 0;}</code></pre><h3 id="2、算法"><a href="#2、算法" class="headerlink" title="2、算法"></a>2、算法</h3><h4 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h4><pre><code>list&lt;int&gt;::iterator it;for (it = lst.begin(); it != lst.end(); it++)    cout &lt;&lt; *it &lt;&lt; endl;</code></pre><h4 id="元素翻转"><a href="#元素翻转" class="headerlink" title="元素翻转"></a>元素翻转</h4><pre><code>#include &lt;algorithm&gt;reverse(lst.begin(), lst.end());</code></pre><h4 id="元素排序"><a href="#元素排序" class="headerlink" title="元素排序"></a>元素排序</h4><pre><code>#include &lt;algorithm&gt;sort(lst.begin(), lst.end()); // 采用的是从小到大的排序// 如果想从大到小排序，可以采用先排序后反转的方式，也可以采用下面方法:// 自定义从大到小的比较器，用来改变排序方式bool Comp(const int&amp; a, const int&amp; b) {    return a &gt; b;}sort(lst.begin(), lst.end(), Comp);</code></pre><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>1、list 为双向迭代器，故不支持<code>it+=i</code>；</p><p>2、list 不支持下标访问和at方法访问。</p><h2 id="七、代码应用实例–约瑟夫问题"><a href="#七、代码应用实例–约瑟夫问题" class="headerlink" title="七、代码应用实例–约瑟夫问题"></a>七、代码应用实例–约瑟夫问题</h2><pre class=" language-c++"><code class="language-c++">/*约瑟夫问题是：有 n 只猴子，按顺时针方向围成一圈选大王（编号为 1~n），从第 1 号开始报数，一直数到 m，数到 m 的猴子退到圈外，剩下的猴子再接着从 1 开始报数。就这样，直到圈内只剩下一只猴子时，这个猴子就是猴王。编程求输入 n、m 后,输出最后猴王的编号。输入数据：每行是用空格分开的两个整数，第一个是 n，第二个是 m（0<m, n<=1 000 000）。最后一行是：0 0输出要求：对于每行输入数据（最后一行除外），输出数据也是一行，即最后猴王的编号。输入样例：6 212 48 30 0输出样例：517*/#include <list>#include <iostream>using namespace std;int main(){    list<int> monkeys;    int n, m;    while (true) {        cin >> n >> m;        if (n == 0 && m == 0)            break;        monkeys.clear();  //清空list容器        for (int i = 1; i <= n; ++i)  //将猴子的编号放入list            monkeys.push_back(i);        list<int>::iterator it = monkeys.begin();        while (monkeys.size() > 1) { //只要还有不止一只猴子，就要找一只猴子让其出列            for (int i = 1; i < m; ++i) { //报数                ++it;                if (it == monkeys.end())                    it = monkeys.begin();            }            it = monkeys.erase(it); //删除元素后，迭代器失效，                                    //要重新让迭代器指向被删元素的后面            if (it == monkeys.end())                it = monkeys.begin();        }        cout << monkeys.front() << endl; //front返回第一个元素的引用    }    return 0;}</code></pre><p>erase 成员函数返回被删除元素后面那个元素的迭代器。如果被删除的是最后一个元素，则返回 end()。</p><p>这个程序也可以用 vector 实现，但是执行速度要慢很多。因为 vector 的 erase 操作牵涉元素的移动，不能在常数时间内完成，所花费的时间和容器中的元素个数有关；而 list 的 erase 操作只是修改几个指针而已，可以在常数时间内完成。当 n 很大（数十万）时，两种写法在速度上会有明显区别。</p><h2 id="八、参考文献以及博客"><a href="#八、参考文献以及博客" class="headerlink" title="八、参考文献以及博客"></a>八、参考文献以及博客</h2><p>1、<a href="https://www.cnblogs.com/linuxAndMcu/p/10260627.html">https://www.cnblogs.com/linuxAndMcu/p/10260627.html</a></p><p>2、<a href="https://www.cnblogs.com/blog-yejy/p/9535840.html">https://www.cnblogs.com/blog-yejy/p/9535840.html</a></p><p>3、<a href="http://c.biancheng.net/view/351.html">http://c.biancheng.net/view/351.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL--stack</title>
      <link href="2020/100528132.html"/>
      <url>2020/100528132.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、stack的简介"><a href="#一、stack的简介" class="headerlink" title="一、stack的简介"></a>一、stack的简介</h2><p>C++ Stack（堆栈） 是一个容器类的改编，为程序员提供了堆栈的全部功能，也就是说实现了一个先进后出（FILO）的数据结构。</p><p>C++ STL 的堆栈泛化是直接通过现有的序列容器来实现的，默认使用双端队列deque的数据结构，当然，可以采用其他线性结构（vector 或 list等），只要提供堆栈的入栈、出栈、栈顶元素访问和判断是否为空的操作即可。由于堆栈的底层使用的是其他容器，因此，堆栈可看做是一种适配器，将一种容器转换为另一种容器(堆栈容器)。<br>   为了严格遵循堆栈的数据后进先出原则，stack 不提供元素的任何迭代器操作，因此，stack 容器也就不会向外部提供可用的前向或反向迭代器类型。</p><p><strong>c++ stl栈stack的头文件为</strong>: </p><p>#include<stack> </stack></p><h2 id="二、stack操作汇总"><a href="#二、stack操作汇总" class="headerlink" title="二、stack操作汇总"></a>二、stack操作汇总</h2><ul><li>top()：返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，返回值未定义。</li><li>push(const T&amp; obj)：可以将对象副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。</li><li>push(T&amp;&amp; obj)：以移动对象的方式将对象压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。</li><li>pop()：弹出栈顶元素。</li><li>size()：返回栈中元素的个数。</li><li>empty()：在栈中没有元素的情况下返回 true。</li><li>emplace()：用传入的参数调用构造函数，在栈顶生成对象。</li><li>swap(stack<t> &amp; other_stack)：将当前栈中的元素和参数中的元素交换。参数所包含元素的类型必须和当前栈的相同。对于 stack 对象有一个特例化的全局函数 swap() 可以使用。</t></li></ul><h2 id="三、stack的成员函数详解"><a href="#三、stack的成员函数详解" class="headerlink" title="三、stack的成员函数详解"></a>三、stack的成员函数详解</h2><h4 id="创建-stack-对象"><a href="#创建-stack-对象" class="headerlink" title="创建 stack 对象"></a>创建 stack 对象</h4><p>使用堆栈前，先要利用构造函数进行初始化，创建一个堆栈对象，以进行元素的入栈、出栈等操作。</p><p>（1）   stack()<br>   默认构造函数，创建一个空的 stack 对象。<br>   例如，下面一行代码使用默认的 deque 为底层容器，创建一个空的堆栈对象 s 。<br>   stack<int> s;</int></p><p> （2） stack(const stack&amp;)<br>   复制构造函数，用一个 stack 堆栈创建一个新的堆栈。<br>   例如，下面的代码利用 s1 ，创建一个以双向链表为底层容器的空堆栈对象 s2 。<br>   stack&lt;int, list<int> &gt;  s1;<br>   stack&lt;int, list<int> &gt;  s2(s1);</int></int></p><h4 id="元素入栈"><a href="#元素入栈" class="headerlink" title="元素入栈"></a>元素入栈</h4><p>   stack堆栈容器的元素入栈函数为 push 函数。由于 C++ STL 的堆栈函数是不预设大小的，因此，入栈函数就不考虑堆栈空间是否为满，均将元素压入堆栈，从而函数没有标明入栈成功与否的返回值。<br>   如下是他的使用原型：<br>   void push(const value_type&amp; x) </p><h4 id="元素出栈"><a href="#元素出栈" class="headerlink" title="元素出栈"></a>元素出栈</h4><p>   stack容器的元素出栈函数为 pop 函数，由于函数并没有判断堆栈是否为空，才进行元素的弹出，因此，需要自行判断堆栈是否为空，才可执行 pop 函数。<br>   void pop()</p><p>   下面的示例代码，将堆栈的所有元素全部出栈，这也是经常拿来清除stack中的成员</p><pre class=" language-c++"><code class="language-c++"> stack<int> s; while(!s.empty()) {     s.pop();// 出栈  }</code></pre><h4 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><p>   stack容器的栈顶元素的读取函数为 pop 函数，将取出最后入栈的元素，如下是它的使用原型<br>   value_type&amp; top()</p><h4 id="堆栈非空判断"><a href="#堆栈非空判断" class="headerlink" title="堆栈非空判断"></a>堆栈非空判断</h4><p>   随着堆栈元素不断出栈，堆栈可能会出现空的情况，因此，一般需要调用 empty 函数判断是否非空，才作元素出栈和取栈顶元素的操作。<br>   bool empty()<br>   判断堆栈是否为空，返回 true 表示堆栈已空，false 表示堆栈非空。</p><h2 id="四、栈的实现原理"><a href="#四、栈的实现原理" class="headerlink" title="四、栈的实现原理"></a>四、栈的实现原理</h2><p>以某种既有容器作为底部结构，将其接口改变，使之符合“先进后出”的特性，形成一个 stack，是很容易做到的。deque 是双向开口的数据结构，若以 deque 为底部结构并封闭其头端开口，便轻而易举地形成了一个 stack。因此，STL便以 deque 作为缺省情况下的 stack 底部结构。</p><p>  由于 stack 系以底部容器完成其所有工作，而具有这种“修改某物接口，形成另一种风貌”之性质者，称为 adapter（配接器），因此 stack 往往被归类为容器配接器。</p><h2 id="五、栈的完整定义"><a href="#五、栈的完整定义" class="headerlink" title="五、栈的完整定义"></a>五、栈的完整定义</h2><pre class=" language-C++"><code class="language-C++">stl_stack.h// Filename:    stl_stack.h#ifndef __SGI_STL_INTERNAL_STACK_H#define __SGI_STL_INTERNAL_STACK_H__STL_BEGIN_NAMESPACE// 如果编译器不能根据前面模板参数推导出后面使用的默认参数类型,// 那么就需要手工指定, 本实作stack内部容器默认使用deque// 选用deque可以在存储空间不足时可以动态增加, 而且代价很低#ifndef __STL_LIMITED_DEFAULT_TEMPLATEStemplate <class T, class Sequence = deque<T> >#elsetemplate <class T, class Sequence>#endifclass stack{  // 特化的全局运算符, 提供operator==和<重载则构建出所有运算符  // 其具体细节见<stl_pair.h>中的说明  friend bool operator== __STL_NULL_TMPL_ARGS (const stack&, const stack&);  friend bool operator< __STL_NULL_TMPL_ARGS (const stack&, const stack&);public:  // 由于stack仅支持对栈顶元素的操作, 所以不定义STL要求的  // pointer, iterator, difference_type  typedef typename Sequence::value_type value_type;  typedef typename Sequence::size_type size_type;  typedef typename Sequence::reference reference;  typedef typename Sequence::const_reference const_reference;protected:  Sequence c;   // 这个是我们实际维护的容器public:  // 下面的操作完全使用内部容器的成员函数实现  // 这再次体现了STL高度的可复用性:-)  // 判断stack是否为空  bool empty() const { return c.empty(); }  // stack中元素个数  size_type size() const { return c.size(); }  // 返回栈顶元素, 注意这里返回的是引用!!!  reference top() { return c.back(); }  const_reference top() const { return c.back(); }  // 在栈顶追加新元素  void push(const value_type& x) { c.push_back(x); }  // 移除栈顶元素, 注意不返回元素的引用,  // 很多初学者随机用此容器时经常误认为pop()操作同时会返回栈顶元素的引用  void pop() { c.pop_back(); }};// 判断两个stack是否相等, 就要测试其内部维护容器是否相等// x.c == y.c会调用容器重载的operator ==template <class T, class Sequence>bool operator==(const stack<T, Sequence>& x, const stack<T, Sequence>& y){  return x.c == y.c;}template <class T, class Sequence>bool operator<(const stack<T, Sequence>& x, const stack<T, Sequence>& y){  return x.c < y.c;}__STL_END_NAMESPACE#endif /* __SGI_STL_INTERNAL_STACK_H */// Local Variables:// mode:C++// End:</code></pre><p>stack虽然默认基于deque（双端队列）实现的，但是我们可以传入参数，使其底层以其他可以的顺序容器来实现，比如：</p><pre class=" language-c++"><code class="language-c++">stack<int, list<int>> stack<int, vector<int>>stack<int, array<int>></code></pre><p>下面给出stl的stack的使用示例：</p><pre class=" language-c++"><code class="language-c++">// constructing stacks#include <iostream>       // std::cout#include <stack>          // std::stack#include <vector>         // std::vector#include <deque>          // std::dequeint main (){  std::deque<int> mydeque (3,100);          // deque with 3 elements  std::vector<int> myvector (2,200);        // vector with 2 elements  std::stack<int> first;                    // empty stack  std::stack<int> second (mydeque);         // stack initialized to copy of deque  std::stack<int,std::vector<int> > third;  // empty stack using vector  std::stack<int,std::vector<int> > fourth (myvector);  std::cout << "size of first: " << first.size() << '\n';  std::cout << "size of second: " << second.size() << '\n';  std::cout << "size of third: " << third.size() << '\n';  std::cout << "size of fourth: " << fourth.size() << '\n';  second.push(2);  std::cout << "The element at the top of stack second is: "        << second.top( ) << "." << std::endl;  std::cout << "size of second: " << second.size() << '\n';  return 0;}Output:size of first: 0size of second: 3size of third: 0size of fourth: 2The element at the top of stack second is:2 .size of second: 4</code></pre><h2 id="六、stack的使用注意事项"><a href="#六、stack的使用注意事项" class="headerlink" title="六、stack的使用注意事项"></a>六、stack的使用注意事项</h2><p>1、stack的pop()以及push()都是void类型，并没有返回值</p><p>2、因为stack的pop()成员是有返回值的，并且返回值类型是_Container::reference类型，也就是stack的引用类型。</p><p>3、stack底层一般用<strong>list或deque</strong>实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时。用其他容器做底层数据结构也可是实现栈，vector、list也支持empty、size、back、push_back、pop_back操作。如果用vector在重新分配空间时需要拷贝原来空间的元素，释放原来空间。如果使用list的话，每一次push_back、pop_back都涉及空间的分配和释放。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL--vector</title>
      <link href="2020/100417570.html"/>
      <url>2020/100417570.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、vector的简介"><a href="#一、vector的简介" class="headerlink" title="一、vector的简介"></a>一、vector的简介</h3><p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。</p><p>vector是C++标准模版库(STL,Standard Template Library)中的部分内容。之所以认为是一个容器，是因为它能够像容器一样存放各种类型的对象，简单的说：vector是一个能够存放任意类型的动态数组，能够增加和压缩数据。</p><p>使用vector容器之前必须加上<vector>头文件：#include<vector>;</vector></vector></p><p>vector属于std命名域的内容，因此需要通过命名限定：using std::vector;也可以直接使用全局的命名空间方式：using namespace std;</p><h3 id="二、容器的特性"><a href="#二、容器的特性" class="headerlink" title="二、容器的特性"></a>二、容器的特性</h3><h5 id="顺序序列"><a href="#顺序序列" class="headerlink" title="顺序序列"></a>顺序序列</h5><p>顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</p><h5 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h5><p>支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。操供了在序列末尾相对快速地添加/删除元素的操作。</p><h5 id="能够感知内存分配器的（Allocator-aware）"><a href="#能够感知内存分配器的（Allocator-aware）" class="headerlink" title="能够感知内存分配器的（Allocator-aware）"></a>能够感知内存分配器的（Allocator-aware）</h5><p>容器使用一个内存分配器对象来动态地处理它的存储需求。</p><h3 id="三、基本函数实现"><a href="#三、基本函数实现" class="headerlink" title="三、基本函数实现"></a>三、基本函数实现</h3><h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h4><ul><li>vector():创建一个空vector</li><li>vector(int nSize):创建一个vector,元素个数为nSize</li><li>vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t</li><li>vector(const vector&amp;):复制构造函数</li><li>vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</li></ul><h4 id="2-插入函数"><a href="#2-插入函数" class="headerlink" title="2.插入函数"></a>2.插入函数</h4><ul><li>void push_back(const T&amp; x):向量尾部增加一个元素X</li><li>iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x</li><li>iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x</li><li>iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</li></ul><h4 id="3-删除函数"><a href="#3-删除函数" class="headerlink" title="3.删除函数"></a>3.删除函数</h4><ul><li>iterator erase(iterator it):删除向量中迭代器指向元素</li><li>iterator erase(iterator first,iterator last):删除向量中[first,last)中元素</li><li>void pop_back():删除向量中最后一个元素</li><li>void clear():清空向量中所有元素</li></ul><h4 id="4-遍历函数"><a href="#4-遍历函数" class="headerlink" title="4.遍历函数"></a>4.遍历函数</h4><ul><li>reference at(int pos):返回pos位置元素的引用</li><li>reference front():返回首元素的引用</li><li>reference back():返回尾元素的引用</li><li>iterator begin():返回向量头指针，指向第一个元素</li><li>iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置</li><li>reverse_iterator rbegin():反向迭代器，指向最后一个元素</li><li>reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</li></ul><h4 id="5-判断函数"><a href="#5-判断函数" class="headerlink" title="5.判断函数"></a>5.判断函数</h4><ul><li>bool empty() const:判断向量是否为空，若为空，则向量中无元素</li></ul><h4 id="6-大小函数"><a href="#6-大小函数" class="headerlink" title="6.大小函数"></a>6.大小函数</h4><ul><li>int size() const:返回向量中元素的个数</li><li>int capacity() const:返回当前向量所能容纳的最大元素值</li><li>int max_size() const:返回最大可允许的vector元素数量值</li></ul><h4 id="7-其他函数"><a href="#7-其他函数" class="headerlink" title="7.其他函数"></a>7.其他函数</h4><ul><li>void swap(vector&amp;):交换两个同类型向量的数据</li><li>void assign(int n,const T&amp; x):设置向量中第n个元素的值为x</li><li>void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</li></ul><h4 id="8-看着清楚"><a href="#8-看着清楚" class="headerlink" title="8.看着清楚"></a>8.看着清楚</h4><blockquote><p>1.push_back 在数组的最后添加一个数据</p><p>2.pop_back 去掉数组的最后一个数据</p><p>3.at 得到编号位置的数据</p><p>4.begin 得到数组头的指针</p><p>5.end 得到数组的最后一个单元+1的指针</p><p>6．front 得到数组头的引用</p><p>7.back 得到数组的最后一个单元的引用</p><p>8.max_size 得到vector最大可以是多大</p><p>9.capacity 当前vector分配的大小</p><p>10.size 当前使用数据的大小</p><p>11.resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值</p><p>12.reserve 改变当前vecotr所分配空间的大小</p><p>13.erase 删除指针指向的数据项</p><p>14.clear 清空当前的vector</p><p>15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1)</p><p>16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1)</p><p>17.empty 判断vector是否为空</p><p>18.swap 与另一个vector交换数据</p></blockquote><h3 id="四、基本用法"><a href="#四、基本用法" class="headerlink" title="四、基本用法"></a>四、基本用法</h3><pre><code>#include &lt; vector&gt; using namespace std;</code></pre><hr><h3 id="五、简单介绍"><a href="#五、简单介绍" class="headerlink" title="五、简单介绍"></a>五、简单介绍</h3><ol><li>vector&lt;类型&gt;标识符</li><li>vector&lt;类型&gt;标识符(最大容量)</li><li>vector&lt;类型&gt;标识符(最大容量,初始所有值)</li><li>int i[5]={1,2,3,4,5}<br>vector&lt;类型&gt;vi(I,i+2);//得到i索引值为3以后的值</li><li>vector&lt; vector&lt; int&gt; &gt;v; 二维向量//这里最外的&lt;&gt;要有空格。否则在比较旧的编译器下无法通过</li></ol><h3 id="六、具体实例"><a href="#六、具体实例" class="headerlink" title="六、具体实例"></a>六、具体实例</h3><h5 id="1-push-back-elem-在尾部插入一个elem数据。"><a href="#1-push-back-elem-在尾部插入一个elem数据。" class="headerlink" title="1.push_back(elem)在尾部插入一个elem数据。"></a>1.push_back(elem)在尾部插入一个elem数据。</h5><pre><code> vector&lt;int&gt; v; v.push_back(1);</code></pre><h5 id="2-pop-back-删除末尾的数据。"><a href="#2-pop-back-删除末尾的数据。" class="headerlink" title="2.pop_back()删除末尾的数据。"></a>2.pop_back()删除末尾的数据。</h5><pre><code> vector&lt;int&gt; v; v.pop_back();</code></pre><h5 id="3-assign-beg-end-将-beg-end-一个左闭右开区间的数据赋值给调用这个函数的vector。"><a href="#3-assign-beg-end-将-beg-end-一个左闭右开区间的数据赋值给调用这个函数的vector。" class="headerlink" title="3.assign(beg,end)将[beg,end)一个左闭右开区间的数据赋值给调用这个函数的vector。"></a>3.assign(beg,end)将[beg,end)一个左闭右开区间的数据赋值给调用这个函数的vector。</h5><pre><code>vector&lt;int&gt; v1,v2;v1.push_back(10);v1.push_back(20);v2.push_back(30);v2.assign(v1.begin(),v1.end());</code></pre><h5 id="4-assign-n-elem-将n个elem的拷贝赋值给调用的vector"><a href="#4-assign-n-elem-将n个elem的拷贝赋值给调用的vector" class="headerlink" title="4.assign (n,elem)将n个elem的拷贝赋值给调用的vector"></a>4.assign (n,elem)将n个elem的拷贝赋值给调用的vector</h5><pre><code>vector&lt;int&gt; v;v.assign(5,10);//往v里放5个10</code></pre><h5 id="5-at-int-index-传回索引为index的数据-如果index越界-抛出out-of-range异常。"><a href="#5-at-int-index-传回索引为index的数据-如果index越界-抛出out-of-range异常。" class="headerlink" title="5.at(int index)传回索引为index的数据,如果index越界,抛出out_of_range异常。"></a>5.at(int index)传回索引为index的数据,如果index越界,抛出out_of_range异常。</h5><pre><code>vecto&lt;int&gt; v;cout &lt;&lt; v.at(2) &lt;&lt; endl;//打印vector中下标是2的数据</code></pre><h5 id="6-begin-返回指向第一个数据的迭代器。"><a href="#6-begin-返回指向第一个数据的迭代器。" class="headerlink" title="6.begin()返回指向第一个数据的迭代器。"></a>6.begin()返回指向第一个数据的迭代器。</h5><h5 id="end-返回指向最后一个数据之后的迭代器。"><a href="#end-返回指向最后一个数据之后的迭代器。" class="headerlink" title="end()返回指向最后一个数据之后的迭代器。"></a>end()返回指向最后一个数据之后的迭代器。</h5><pre><code>vector&lt;int&gt; v;v.push_back(1);v.push_back(2);v.push_back(3);vector&lt;int&gt;::iterator it;for(it = v.begin();it!=v.end();it++){    cout &lt;&lt; *it &lt;&lt; " ";}cout &lt;&lt; endl;</code></pre><h5 id="7-rbegin-返回逆向队列的第一个数据-即c容器的最后一个数据。"><a href="#7-rbegin-返回逆向队列的第一个数据-即c容器的最后一个数据。" class="headerlink" title="7.rbegin()返回逆向队列的第一个数据,即c容器的最后一个数据。"></a>7.rbegin()返回逆向队列的第一个数据,即c容器的最后一个数据。</h5><h5 id="rend-返回逆向队列的最后一个数据的下一个位置-即c容器的第一个数据再往前的一个位置。"><a href="#rend-返回逆向队列的最后一个数据的下一个位置-即c容器的第一个数据再往前的一个位置。" class="headerlink" title="rend()返回逆向队列的最后一个数据的下一个位置,即c容器的第一个数据再往前的一个位置。"></a>rend()返回逆向队列的最后一个数据的下一个位置,即c容器的第一个数据再往前的一个位置。</h5><pre><code>vector&lt;int&gt; v;v.push_back(1);v.push_back(2);v.push_back(3);vector&lt;int&gt;::reverse_iterator it;for(it = v.rbegin();it!=v.rend();it++){    cout &lt;&lt; *it &lt;&lt; "\t";}cout &lt;&lt; endl;</code></pre><h5 id="8-capacity-返回容器中数据个数-翻倍增长。"><a href="#8-capacity-返回容器中数据个数-翻倍增长。" class="headerlink" title="8.capacity()返回容器中数据个数,翻倍增长。"></a>8.capacity()返回容器中数据个数,翻倍增长。</h5><pre><code>vector&lt;int&gt; v;v.push_back(1);cout &lt;&lt; v.capacity() &lt;&lt; endl;  // 1v.push_back(2);cout &lt;&lt; v.capacity() &lt;&lt; endl;  // 2v.push_back(3);cout &lt;&lt; v.capacity() &lt;&lt; endl; // 4</code></pre><p><strong>9.使用reverse将元素翻转</strong>：</p><p>需要头文件#include<algorithm>,<br>reverse(vec.begin(),vec.end());<br>将元素翻转（在vector中，如果一个函数中需要两个迭代器，一般后一个都不包含）。</algorithm></p><p><strong>使用sort排序：</strong></p><p>需要头文件#include<algorithm>，<br>sort(vec.begin(),vec.end());(默认是按升序排列,即从小到大)。</algorithm></p><p>可以通过重写排序比较函数按照降序比较，如下：<br>定义排序比较函数：</p><p>bool Comp(const int &amp;a,const int &amp;b)<br>{<br>return a&gt;b;<br>}</p><p>调用时:sort(vec.begin(),vec.end(),Comp)，这样就降序排序。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>the summary of &#39;Making Smart Contracts Smarter&#39;</title>
      <link href="2020/09308489.html"/>
      <url>2020/09308489.html</url>
      
        <content type="html"><![CDATA[<h2 id="The-Summary-of-“Making-Smart-Contracts-Smarter”"><a href="#The-Summary-of-“Making-Smart-Contracts-Smarter”" class="headerlink" title="The Summary of “Making Smart Contracts Smarter”"></a>The Summary of “Making Smart Contracts Smarter”</h2><h3 id="I-introduction"><a href="#I-introduction" class="headerlink" title="I.   introduction"></a><strong>I.</strong>   <strong>introduction</strong></h3><p>This paper focuses on the topics of smart contracts and Oyente. The authors recorded several new security bugs in Ethereum smart contracts, and at the same time formalize the semantics of Ethereum smart contracts to provide solutions for the security bugs proposed in the paper. In order to find security bugs in smart contracts, the authors built a symbolic execution tool called Oyente to find potential security bugs, and introduce Oynete’s specific design. </p><h3 id="II-samrt-contracts-and-oyente"><a href="#II-samrt-contracts-and-oyente" class="headerlink" title="II.  samrt contracts  and oyente"></a><strong>II.</strong>  <strong>samrt contracts  and oyente</strong></h3><h5 id="A-Smart-Contracts-in-Ethereum"><a href="#A-Smart-Contracts-in-Ethereum" class="headerlink" title="A.  Smart Contracts in Ethereum"></a>A.  Smart Contracts in Ethereum</h5><p>Firstly, a brief introduction to the Ethereum smart contract and its execution model. The contract state consists of two main parts: private storage and the amount of virtual currency it holds. The code of the Ethereum smart contract is written in a stack-based bytecode language and executed in the EVM. Several high-level languages can be used to write the Ethereum smart contract, and then these codes will be compiled into EVM bytecode to run. In order to ensure fair compensation for the calculation workload, Ethereum pays a certain percentage of calculation fees to the Leader node. Here is an introduction to “gasLimit” and “gasPrice”, and the relationship between them.</p><h5 id="B-Security-Bugs"><a href="#B-Security-Bugs" class="headerlink" title="B.  Security Bugs"></a>B.  Security Bugs</h5><p>In this paper, it is mentioned that the infamous attack on “TheDAO” caused a loss of about $60 million to TheDAO’s investors, in order to illustrate the destructive nature of smart contracts and why smart contracts are attractive. The authors discuss four major categories of vulnerabilities in smart contracts: transaction-ordering dependence, timestamp dependence, mishandled exceptions, and reentrancy vulnerability. These vulnerabilities allow malicious miners or users to mine and make profits. Attackers can influence the execution results of smart contracts or steal funds by changing the order of transactions, modifying time stamps, calling reentrant functions, triggering processing exceptions, etc.</p><p>In order to solve the above security vulnerabilities, this paper proposes improvements to the operational semantics of Ethereum. However, to deploy these proposals, all clients in the Ethereum network must be upgraded. In order for developers to better write better contracts and users to avoid calling problematic contracts, the author provides a tool called Oyente.</p><h5 id="C-Oyente-An-Analyzer-for-Smart-Contracts"><a href="#C-Oyente-An-Analyzer-for-Smart-Contracts" class="headerlink" title="C.  Oyente: An Analyzer for Smart Contracts"></a>C.  Oyente: An Analyzer for Smart Contracts</h5><p>Based on a model of the operational semantics of the Ethereum bytecode, the authors build a verification tool called Oyente which can symbolically execute contracts and look for vulnerabilities. The authors chose symbolic execution because it allows statically path-by-path reasoning programs. Oyente is 4,00 lines of Python, and uses Z3 as the solver to decide satisfiability. </p><p>The paper depicts the architecture overview of Oyente. On the basis of symbolic execution, Oyente can output the control flow graph of the smart contract, analyze the reachable path, and detect possible abnormalities in the path according to a series of rules, and finally verify the detected abnormalities to reduce errors. Newspaper. It needs two inputs, the bytecode of the analyzed contract and the current global state of Ethereum. It answers whether there are any security issues with the contract and outputs the symbolic path in question.</p><p>It has separate modules and it can add more analysis separately. It consists of four main components, namely CFGBuilder, Explorer, CoreAnalysis and Validator. The core part is CoreAnalysis, which transforms the path of explorer just output, and only contains some paths of Ether from the beginning to the end, and performs some vulnerability verification. Using the constraint solver Z3 can reduce the false alarm rate and false alarm rate of the entire system. At present, Oyente only provides verification of three security problems, namely TOD, Timestamp dependence, and Mishandled Exceptions. </p><p>The current Oyente is not perfect. What its main purpose now is that marking potentially vulnerable contracts. For some vulnerabilities in contracts, manual analysis is needed to confirm, which means that comprehensive false positive detection will be left to the future work. </p><h5 id="D-Test-Results"><a href="#D-Test-Results" class="headerlink" title="D.  Test Results"></a>D.  Test Results</h5><p>Finally, in the benchmark test, Oyente was run with 19,366 contracts from the blockchain as of May 5, 2016 for quantitative and qualitative analysis to determine the performance of Oyente.  It needs 350 seconds on average to analyze the contract. Among them, 8,833 of the contracts have at least one security issue: 5,411 contracts (27.9%) have mishandled exceptions; 3,056 contracts (15.7%) have transaction-ordering dependencies; 83 contracts have timestamp dependencies, and 340 contracts have reentrancy vulnerabilities – one of which is the infamous “TheDAO” contract. The section 6 of the paper specifically introduces some examples of security vulnerabilities. </p><h3 id="III-conclusion"><a href="#III-conclusion" class="headerlink" title="III. conclusion"></a><strong>III.</strong> <strong>conclusion</strong></h3><p>This paper summarizes the security vulnerabilities of Ethereum smart contracts and Oyente’s design. The authors propose several security bugs in current smart contracts. In order to better detect security bugs, they also built the smart contract analyzer named Oyente. By introducing the overview of Oyente, they explained how to make smart contracts smarter. The content discussed is only for the Ethereum smart contract platform, but security vulnerabilities may also involve other open distributed application platforms. At the same time, Oyente’s project is open sourced, so that more people discover the defects of Oyente and improve the function and performance of Oyente. </p><h3 id="IV-The-original-link"><a href="#IV-The-original-link" class="headerlink" title="IV.The original link"></a>IV.The original link</h3><p>If you’re interested, you can read the original paper.</p><p><a href="https://xueshu.baidu.com/usercenter/paper/show?paperid=8a4931d918054adfa87a9db948b45a20&amp;site=xueshu_se">点击查看原文</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 论文总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式计算的概念</title>
      <link href="2020/093022851.html"/>
      <url>2020/093022851.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h1><p>​       分布式计算( Distributed computing )是一种把需要进行大量计算的工程数据分割成小块，由多台计算机分别计算，在上传运算结果后，将结果统一合并得出数据结论的科学。目前常见的分布式计算项目通常使用世界各地上千万志愿者计算机的闲置计算能力，通过互联网进行数据传输。</p><h5 id="1-何为分布式"><a href="#1-何为分布式" class="headerlink" title="1.何为分布式"></a>1.何为分布式</h5><p>分布式就是计算机的一种算法。其实可以形象的将其比喻为撒网捕鱼，渔网中的每个节点都负责着各自的自责（不能脱离渔网，要牢不可破）。</p><h5 id="2-何谓分布式存储"><a href="#2-何谓分布式存储" class="headerlink" title="2.何谓分布式存储"></a>2.<em>何谓分布式存储</em></h5><p>分布式存储技术是利用网络将数据分散地存储于多台独立的机器设备上。核心点是数据、网络、多台主机。</p><h5 id="3-分布式计算"><a href="#3-分布式计算" class="headerlink" title="3.分布式计算"></a>3.<em>分布式计算</em></h5><p>所谓分布式计算是一门计算机科学，它研究如何把一个需要非常巨大的计算能力才能解决的问题分成许多小的部分，然后把这些部分分配给许多计算机进行处理，最后把这些计算结果综合起来得到最终的结果。</p><p>明确了以上几个概念之后，我们需要将抽象的理论转变成一些可以学习的技术。那目前到底有哪一些是这个理论的实现方式呢？其实有很多关于分布式计算和存储的技术，比如Google的GFS和MapReduce，Hadoop中的hdfs和MapReduce，流式计算领域的Storm、Spark Streaming等。面对这些目不暇接的技术时，我们需要做一些权衡，到底需要给学生学习什么技术好一些呢？其实作为教学的话，往往偏向于从基础入手，那分布式最开始的时候是由Google发明的，当时互联网泡沫刚刚结束之后，Google采取了所谓的低成本之路的策略，需要将许许多多廉价的PC机串联起来，形成一个巨大的分布式主机网络。随之发表了GFS（Google File System）的论文，之后又发表了MapReduce分布式计算和BigTable的论文，这三篇论文的出现，奠定了分布式计算和存储技术的基础。至于Hadoop和HBase就是GFS、MapReduce、BigTable的开源实现。我们无法学习Google的分布式计算，但是我们可以学习开源的Hadoop分布式计算框架。这个也就是我们选择Hadoop来教学的原因。</p><pre><code>   那Hadoop如何体现了分布式存储和分布式计算的原理呢？其实就是Hadoop的内部的两个核心部件：HDFS（Hadoop Distributed File System）和MapReduce。</code></pre><p>  （1）HDFS（Hadoop Distributed File System）即Hadoop分布式文件系统，它解决了分布式存储的问题；</p><p>  （2）MapReduce即分布式计算模型，它解决了分布式计算的问题；</p><pre><code> 因此，针对分布式计算原理的课程，其主要内容就是学习Hadoop，学习Hadoop的HDFS和MapReduce以及Hadoop生态圈外围的一些组件。</code></pre><h5 id="4-分布式和集群的区别？"><a href="#4-分布式和集群的区别？" class="headerlink" title="4.分布式和集群的区别？"></a>4.<strong>分布式和集群的区别？</strong></h5><p>分布式：一个业务分拆多个子业务，部署在不同的服务器上，实现的功能是有差异的，主要用于解决高并发问题。</p><p>集群：同一个业务，部署在多个服务器上，实现相同的功能。系统在做负载均衡的时候，看看哪个服务器比较空闲，就将任务分配给哪个服务器。主要解决系统高可用的问题。</p><p>比如，一个业务可以拆分成10个子业务，每个子业务完成需要1个小时，现在将他部署到10个服务器上，那么一个小时就可以完成，10个业务就需要10个小时（分布式）。<br>现在将该业务部署到由10台服务器组成的集群服务器上，单个任务完成的时间还是10小时，但是10个任务的完成时间还是10小时（集群）。</p><h1 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h1><h5 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h5><p>云计算（cloud computing）是基于互联网的相关服务的增加、使用和交付模式，通常涉及通过互联网来提供动态易扩展且经常是虚拟化的资源。云是网络、互联网的一种比喻说法。过去在图中往往用云来表示电信网，后来也用来表示互联网和底层基础设施的抽象。因此，云计算甚至可以让你体验每秒10万亿次的运算能力，拥有这么强大的计算能力可以模拟核爆炸、预测气候变化和市场发展趋势。用户通过电脑、笔记本、手机等方式接入数据中心，按自己的需求进行运算。 对云计算的定义有多种说法。对于到底什么是云计算，至少可以找到100种解释。现阶段广为接受的是美国国家标准与技术研究院（NIST）定义：云计算是一种按使用量付费的模式，这种模式提供可用的、便捷的、按需的网络访问， 进入可配置的计算资源共享池（资源包括网络，服务器，存储，应用软件，服务），这些资源能够被快速提供，只需投入很少的管理工作，或与服务供应商进行很少的交互。</p><p>云计算（cloud computing）是分布式计算的一种，指的是通过网络“云”将巨大的数据计算处理程序分解成无数个小程序，然后，通过多部服务器组成的系统进行处理和分析这些小程序得到结果并返回给用户。云计算早期，简单地说，就是简单的分布式计算，解决任务分发，并进行计算结果的合并。因而，云计算又称为网格计算。通过这项技术，可以在很短的时间内（几秒种）完成对数以万计的数据的处理，从而达到强大的网络服务。 </p><p>现阶段所说的云服务已经不单单是一种分布式计算，而是分布式计算、效用计算、负载均衡、并行计算、网络存储、热备份冗杂和虚拟化等计算机技术混合演进并跃升的结果。 [</p><h5 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h5><p>云计算的可贵之处在于高灵活性、可扩展性和高性比等，与传统的网络应用模式相比，其具有如下优势与特点</p><p>1、虚拟化技术。</p><p>必须强调的是，虚拟化突破了时间、空间的界限，是云计算最为显著的特点，虚拟化技术包括应用虚拟和资源虚拟两种。众所周知，物理平台与应用部署的环境在空间上是没有任何联系的，正是通过虚拟平台对相应终端操作完成数据备份、迁移和扩展等。 </p><p>2、动态可扩展。</p><p>云计算具有高效的运算能力，在原有服务器基础上增加云计算功能能够使计算速度迅速提高，最终实现动态扩展虚拟化的层次达到对应用进行扩展的目的。 </p><p>3、按需部署。</p><p>计算机包含了许多应用、程序软件等，不同的应用对应的数据资源库不同，所以用户运行不同的应用需要较强的计算能力对资源进行部署，而云计算平台能够根据用户的需求快速配备计算能力及资源。</p><p>4、灵活性高。</p><p>目前市场上大多数IT资源、软、硬件都支持虚拟化，比如存储网络、操作系统和开发软、硬件等。虚拟化要素统一放在云系统资源虚拟池当中进行管理，可见云计算的兼容性非常强，不仅可以兼容低配置机器、不同厂商的硬件产品，还能够外设获得更高性能计算。 </p><p>5、可靠性高。</p><p>倘若服务器故障也不影响计算与应用的正常运行。因为单点<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8/100571">服务器</a>出现故障可以通过虚拟化技术将分布在不同物理服务器上面的应用进行恢复或利用动态扩展功能部署新的服务器进行计算。 </p><p>6、性价比高。</p><p>将资源放在虚拟资源池中统一管理在一定程度上优化了物理资源，用户不再需要昂贵、存储空间大的主机，可以选择相对廉价的<a href="https://baike.baidu.com/item/PC/107">PC</a>组成云，一方面减少费用，另一方面计算性能不逊于大型主机。 </p><p>7、可扩展性。</p><p>用户可以利用应用软件的快速部署条件来更为简单快捷的将自身所需的已有业务以及新业务进行扩展。如，计算机云计算系统中出现设备的故障，对于用户来说，无论是在计算机层面上，亦或是在具体运用上均不会受到阻碍，可以利用计算机云计算具有的动态扩展功能来对其他服务器开展有效扩展。这样一来就能够确保任务得以有序完成。在对虚拟化资源进行动态扩展的情况下，同时能够高效扩展应用，提高计算机云计算的操作水平。</p><h5 id="3-服务类型"><a href="#3-服务类型" class="headerlink" title="3.服务类型"></a>3.服务类型</h5><p>通常，它的服务类型分为三类，即基础设施即服务(<a href="https://baike.baidu.com/item/IaaS/5863121">IaaS</a>)、平台即服务(<a href="https://baike.baidu.com/item/PaaS/219931">PaaS</a>)和软件即服务(<a href="https://baike.baidu.com/item/SaaS/6703273">SaaS</a>)。这3种云计算服务有时称为云计算堆栈，因为它们构建堆栈，它们位于彼此之上，以下是这三种服务的概述： </p><p>1、基础设施即服务(IaaS)</p><p>基础设施即服务是主要的服务类别之一，它向云计算提供商的个人或组织提供虚拟化计算资源，如虚拟机、存储、网络和操作系统。 </p><p>2、平台即服务(PaaS)</p><p>平台即服务是一种服务类别，为开发人员提供通过全球互联网构建应用程序和服务的平台。Paas为开发、测试和管理软件应用程序提供按需开发环境。 [6] </p><p>3、软件即服务(SaaS)</p><p>软件即服务也是其服务的一类，通过互联网提供按需软件付费应用程序，云计算提供商托管和管理软件应用程序，并允许其用户连接到应用程序并通过全球互联网访问应用程序。</p><h5 id="4-应用"><a href="#4-应用" class="headerlink" title="4.应用"></a>4.应用</h5><p>1、云物联</p><p>“物联网就是物物相连的互联网”。这有两层意思：第一，物联网的核心和基础仍然是互联网，是在互联网基础上的延伸和扩展的网络；第二，其用户端延伸和扩展到了任何物品与物品之间，进行信息交换和通信。</p><p>物联网的两种业务模式：MAI（M2M Application Integration), 内部MaaS；MaaS（M2M As A Service), MMO, Multi-Tenants(多租户模型）。</p><p>云计算：从计算中心到数据中心在物联网的初级阶段，PoP即可满足需求；在物联网高级阶段，可能出现MVNO/MMO营运商（国外已存在多年），需要虚拟化云计算技术，SOA等技术的结合实现互联网的泛在服务：TaaS （everyTHING As A Service)。</p><p>2、云安全</p><p>“云安全”通过网状的大量客户端对网络中软件行为的异常监测，获取互联网中木马、恶意程序的最新信息，推送到Server端进行自动分析和处理，再把病毒和木马的解决方案分发到每一个客户端。</p><h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><h5 id="一-什么是大数据"><a href="#一-什么是大数据" class="headerlink" title="一.什么是大数据"></a>一.什么是大数据</h5><p>大数据最直观的理解，就是数据量很大，但是多大才算是大呢？根据IDC作出的估测，数据一直以每年50%的速度增长，也就意味着数据每两年就增长一倍。 人类在近两年产生的数据相当于之前产生的全部数据量。预计到2020年，全球将总共拥有35ZB（1ZB=1024EB,1EB=1024PB,1PB=1024TB,1TB=1024GB）的数据量。</p><p>其实，大数据不仅仅在与数据量大，大数据还包含了“快速化”、“多样化”、“价值化”等多种属性。</p><p>大数据的处理速度很快，数据从生产到消耗，可用于生成决策的时间是非常短的，也就是大数据中的1秒定律（或称：秒级定律）：就是说对处理速度有要求,一般要在秒级时间范围内给出分析结果,时间太长就失去价值了.这个速度要求是大数据处理技术和传统的数据挖掘技术最大的区别。</p><p>大数据的多样化体现在大数据的数据由10%的结构化数据（存储在数据库中），90%非机构化数据组成，这和人类信息密切相关。如在企业中我们常用的Email、文档、文件，web的文本、图像、视频，以及我们日常用的微信，Twitter、Facebook、Blog等。</p><p>大数据的数据量很大，但是其价值密度也很低，例如：我们路上随处可见的视频监控，在连续不断的监控过程中，产生的大量数据其实都是没什么用的；但是如果发生事故，仅仅就几秒的数据，就会产生极高的价值。所以说尽管大数据的数据价值密度低，但是其商业价值却很高。</p><h5 id="二-大数据的影响"><a href="#二-大数据的影响" class="headerlink" title="二.大数据的影响"></a>二.大数据的影响</h5><p>《大数据时代》这本书中讲到的大数据在思维方面的影响，大数据完全颠覆了传统的思维方式。主要体现在以下三点：</p><p>​    全样而非抽样</p><p>​    效率而非精确</p><p>​    相关而非因果</p><p>现如今，你在使用淘宝购物、百度搜索等应用的时候，你就会发现，它总能给你推荐你想要看的，这是大数据决策的体现，依据大数据分析，去匹配你属于哪一类人群，而从给你推荐这一类人群喜好的东西。</p><p>大数据的新起，也让数据分析师，数据科学家，大数据工程师，数据可视化等职业成为了热门。现如今大数据已经无处不在，包括金融、汽车、零售、餐饮、电信、能源、政务、医疗、体育、娱乐等在内的社会各行各业都融入了大数据的印记。</p><h5 id="三-大数据技术"><a href="#三-大数据技术" class="headerlink" title="三.大数据技术"></a>三.大数据技术</h5><p>数据采集</p><p>​    利用ETL工具将分布的、异构数据源中的数据如关系数据、平面数据文件等，抽取到临时中间层后进行清洗、转换、集成，最后加载到数据仓库或数据集中，成为联机分析处理、数据挖掘的基础；或者也可以把实时采集的数据作为流计算系统的输入，进行实时处理分析。</p><p>​    数据存储和管理</p><p>​    利用分布式文件系统、数据仓库、关系数据库，NoSQL数据库、云数据库等，实现对结构化、半结构化和非结构化海量数据的存储和管理</p><p>​    数据处理与分析</p><p>​    利用分布式并行编程模型和计算框架，结合机器学习和数据挖掘算法，实现对海量数据的处理和分析；对分析结果进行可视化呈现，帮助人们更好的理解数据、分析数据</p><p>​    数据隐私和安全</p><p>​    从大数据中挖掘潜在的商业价值的同时，构建隐私数据保护体系和数据安全体系，有效保护个人隐私和数据安全。</p><p>大数据的核心技术主要是： 分布式存储（HDFS） 和 分布式处理(MapReduce)</p><h1 id="边缘计算"><a href="#边缘计算" class="headerlink" title="边缘计算"></a>边缘计算</h1><p>云计算和边缘计算是两个不同的概念，各有特点，许多人都在研究如何在云计算架构中添加边缘计算，下面来看看可行性及利弊分析。</p><p>边缘计算并非对每个物联网设备或工作负载都具有意义。人们需要了解一些边缘计算示例，以了解应该在何时何地将其作为云计算架构的一部分。</p><p>与传统的云计算架构相比，边缘计算的性能、安全性和成本优势使其越来越受欢迎，但并不总是最适用于分布式工作负载。</p><p>边缘计算是指在最终用户的电脑、手机或物联网传感器等生成和消费数据的设备上或附近处理数据的架构。这不同于传统的云计算，云计算依靠中央服务器来接收数据、处理数据并将其发送回客户端设备。而边缘计算可以减少网络等待时间，减少数据在网络上的暴露，在某些情况下，通过将处理加载到最终用户的设备来降低成本。</p><p>由于具有吸引人的优势，云计算架构师可能希望将尽可能多的工作负载推向边缘计算。但是在这样做之前，他们应该考虑每个应用程序的结构、性能要求和安全性注意事项以及其他因素。两种类型的边缘计算架构</p><p>在权衡边缘计算模型是否合适时，首先要问的问题是哪种架构可用。主要有两种类型：</p><p>设备-边缘计算，其中直接在客户端设备上处理数据。 云计算-边缘计算，其中在边缘计算硬件上处理数据，而边缘计算硬件在地理位置上比集中式云计算数据中心更靠近客户端设备。</p><p>如果客户端设备能够以统一的方式处理该处理负担，则设备-边缘计算模型可以很好地工作。可以采用台式机或笔记本电脑来处理此问题，但低功率物联网传感器可能缺少有效处理数据所需的计算和存储资源。</p><p>此外，如果企业依赖于许多不同类型的边缘设备和操作系统，所有这些设备可能具有不同的功能和配置，那么使用设备-边缘计算模型可能会很困难。</p><p>借助云计算-边缘计算模型，最终用户设备并不是塑造架构的主要因素。如果企业使用云计算-边缘计算架构，那么最终用户使用的设备类型并不重要，因为不会将数据存储或处理从中央云转移到这些设备。与其相反，企业需要将负载转移到在云计算-边缘计算运行的服务器。这些服务器通常位于比中央云更靠近最终用户的数据中心。</p><p>边缘计算的局限性</p><p>在企业决定将工作负载移至边缘计算之前，需要评估支持这些边缘计算模型是否合理。这些限制可能使企业回到传统的云计算架构。</p><p>边缘安全</p><p>边缘计算通过很大程度地减少数据传输时间来降低一些安全风险，但同时也带来了更复杂的安全挑战。</p><p>例如，如果企业在不受控制的最终用户设备上存储或处理数据，很难保证这些设备没有受到网络攻击者可能利用的漏洞的攻击。即使使用云计算-边缘计算模型来保留对边缘计算基础设施的控制，拥有更多可管理基础设施也会增加攻击面。</p><p>与保护正在处理的数据相比，保护通过网络传输的数据(可以对其进行加密)通常要容易得多。因此，边缘计算的安全性的弊端可能超过其好处。</p><p>这使得边缘计算对于具有高安全性规范的工作负载而言并非理想选择。如果企业要处理敏感数据或有特殊的合规性要求，则具有集中式服务器的标准云计算模型的风险可能会降低。</p><p>延迟要求</p><p>边缘计算可提高应用程序性能和响应能力，因为数据不必往返于云计算的数据中心进行处理。对于需要真正即时通信流的工作负载，这是一个关键优势。云计算提供商继续增加数据中心的位置，但是他们的大型数据中心设施通常位于远离人口中心的偏远位置。</p><p>大多数工作负载具有较低的延迟标准。与传统的云计算架构相比，边缘计算网络可能只会将网络响应速度提高几毫秒。对于标准应用，常规架构带来的网络延迟是可以接受的。而确保延迟改善确实值得进行权衡，尤其是在考虑了增加的成本和管理负担之后。</p><p>数据量</p><p>考虑企业的工作负载需要处理多少数据，以及边缘计算基础设施是否可以有效地处理它。如果企业的工作负载产生大量数据，则需要一个庞大的基础设施来分析和存储该数据。从管理的角度来看，它可能成本更低，并且更容易将数据移至公共云数据中心。</p><p>另一方面，如果工作负载基本上是无状态的并且不涉及大量数据，则它们往往是边缘计算的理想选择。</p><p>边缘计算实例</p><p>为了说明上面列出的取舍，以下是边缘计算何时适合和不适合的一些示例。</p><p>采用边缘计算的很好例子包括：</p><p>自动驾驶汽车。自动驾驶汽车会收集大量数据，需要实时做出决策，以确保道路上或附近的乘客和其他人的安全。延迟问题可能会导致自动驾驶汽车的响应时间延迟几毫秒，而这种情况可能会产生严重的影响。 智能恒温器。这些设备生成的数据相对较少。此外，收集的某些数据(例如人们回家的时间和调整温度)可能会影响隐私。将数据保留在边缘计算是切实可行的，可以帮助减轻安全隐患。 交通信号灯。交通信号灯具有三个特征，使其非常适合边缘计算：实时响应变化的需求;相对较低的数据输出;偶尔会失去互联网连接。</p><p>以下是一些边缘计算效果不佳的示例：</p><p>常规应用程序。很难想到需要边缘计算基础设施的性能或响应能力的常规应用程序。它可能会减少应用程序加载或响应请求所需的时间，但这种改进并不值得付出更多成本。 监控摄像系统。监控视频通常会产生大量数据。在边缘计算处理和存储数据是不切实际的，因为这将需要大型且专门的基础设施。将数据存储在集中式云计算设施成本将会低得多，也容易得多。 智能照明系统。允许用户通过互联网控制家庭或办公室中照明的系统不会生成大量数据。但是智能照明系统往往具有最小的处理能力，也没有超低延迟要求，如果打开灯具需要一两秒钟的时间，那没什么大不了的。用户可以构建用于管理这些系统的边缘基础设施，但这在大多数情况下都不值得花费更多的成本。</p><h1 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h1><p>并行计算或称平行计算是相对于串行计算来说的。它是一种一次可执行多个指令的算法，目的是提高计算速度，及通过扩大问题求解规模，解决大型而复杂的计算问题。所谓并行计算可分为时间上的并行和空间上的并行。 时间上的并行就是指<a href="https://baike.baidu.com/item/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/1119843">流水线技术</a>，而空间上的并行则是指用多个<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E5%99%A8/914419">处理器</a>并发的执行计算。</p><p>并行计算与云计算</p><p><a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97">云计算</a>是在并行计算之后产生的概念，是由并行计算发展而来， 两者在很多方面有着共性。学习并行计算对于理解<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97">云计算</a>有很大的帮助。并行计算是学习<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97">云计算</a>必须要学习的基础课程。</p><p>但并行计算不等于云计算，<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97">云计算</a>也不等同并行计算。两者区别如下。</p><p>（1）<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97">云计算</a>萌芽于并行计算</p><p><a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97">云计算</a>的萌芽应该从<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>的并行化开始，并行机的出现是人们不满足于CPU摩尔定率的增长速度，希望把多个计算机并联起来，从而获得更快的计算速度。这是一种很简单也很朴素的实现高速计算的方法，这种方法后来被证明是相当成功的。</p><p>（2）并行计算、<a href="https://baike.baidu.com/item/%E7%BD%91%E6%A0%BC%E8%AE%A1%E7%AE%97">网格计算</a>只用于特定的科学领域，专业的用户</p><p>并行计算、<a href="https://baike.baidu.com/item/%E7%BD%91%E6%A0%BC%E8%AE%A1%E7%AE%97">网格计算</a>的提出主要是为了满足科学和技术领域的专业需要，其应用领域也基本限于科学领域。传统并行<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>的使用是一个相当专业的工作，需要使用者有较高的专业素质，多数是命令行的操作，这是很多专业人士的噩梦，更不用说普通的业余级用户了。</p><p>（3）并行计算追求的高性能</p><p>在并行计算的时代，人们极力追求的是高速的计算、采用昂贵的服务器，各国不惜代价在计算速度上超越他国，因此，并行计算时代的高性能<a href="https://baike.baidu.com/item/%E6%9C%BA%E7%BE%A4">机群</a>是一个“快速消费品”，世界TOP500高性能<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>地排名不断地在刷新，一台大型机群如果在3年左右不能得到有效的利用就远远的落后了，巨额投资无法收回。</p><p>（4）<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97">云计算</a>对于单节点的计算能力要求低</p><p>而<a href="https://baike.baidu.com/item/%E4%BA%91%E8%AE%A1%E7%AE%97">云计算</a>时代我们并不去追求使用昂贵的服务器，我们也不用去考虑TOP500的排名，云中心的计算力和存储力可随着需要逐步增加，云计算的基础架构支持这一动态增加的方式，高性能计算将在云计算时代成为“耐用消费品”。</p><h1 id="高性能计算"><a href="#高性能计算" class="headerlink" title="高性能计算"></a>高性能计算</h1><p> 高性能计算(High performance computing) 指通常使用很多处理器(作为单个机器的一部分)或者某一集群中组织的几台计算机(作为单个计算资源操作)的计算系统和环境。高性能集群上运行的应用程序一般使用并行算法，把一个大的普通问题根据一定的规则分为许多小的子问题，在集群内的不同节点上进行计算，而这些小问题的处理结果，经过处理可合并为原问题的最终结果。由于这些小问题的计算一般是可以并行完成的，从而可以缩短问题的处理时间。</p><pre><code>  高性能集群在计算过程中，各节点是协同工作的，它们分别处理大问题的一部分，并在处理中根据需要进行数据交换，各节点的处理结果都是最终结果的一部分。高性能集群的处理能力与集群的规模成正比，是集群内各节点处理能力之和，但这种集群一般没有高可用性。高性能计算的分类方法很多。这里从并行任务间的关系角度来对高性能计算分类。</code></pre><p>一、高吞吐计算(High-throughput Computing)</p><pre><code>  有一类高性能计算，可以把它分成若干可以并行的子任务，而且各个子任务彼此间没有什么关联。因为这种类型应用的一个共同特征是在海量数据上搜索某些特定模式，所以把这类计算称为高吞吐计算。所谓的Internet计算都属于这一类。按照Flynn的分类，高吞吐计算属于SIMDSingle Instruction/Multiple Data，单指令流-多数据流)的范畴。</code></pre><p>二、分布计算(Distributed Computing)</p><pre><code>  另一类计算刚好和高吞吐计算相反，它们虽然可以给分成若干并行的子任务，但是子任务间联系很紧密，需要大量的数据交换。按照Flynn的分类，分布式的高性能计算属于MIMD（Multiple Instruction/Multiple Data，多指令流-多数据流）的范畴。  有许多类型的HPC 系统，其范围从标准计算机的大型集群，到高度专用的硬件。大多数基于集群的HPC系统使用高性能网络互连，基本的网络拓扑和组织可以使用一个简单的总线拓扑。HPC系统由计算、存储、网络、集群软件四部分组成。</code></pre><p>高性能计算HPC系统技术特点是什么？</p><pre><code>  HPC系统目前主流处理器是X86处理器，操作系统是linux 系统(包括Intel、AMD、NEC、Power、PowerPC、Sparc等)、构建方式采用刀片系统，互联网络使用IB和10GE。  高性能计算HPC集群中计算节点一般 分3种: MPI节点、胖节点、GPU加速节点。双路节点称为瘦节点(MPI节点)，双路以上称为胖节点；胖节点配置大容量内存；集群中胖节点的数量要根据实际应用需求而定。  GPU英文全称Graphic Processing Unit，中文翻译为图形处理器。 在浮点运算、并行计算等部分计算方面，GPU可以提供数十倍乃至于上百倍于CPU的性能。目前GPU厂家只有三家NVIDIA GPU、AMD GPU和Intel Xeon PHI。可选择的GPU种类比较少。</code></pre><p>NVIDIA 的GPU卡分图形卡和计算卡，图形卡有NVIDA K2000与K4000，计算卡K20X/K40M/K80 。</p><p>Intel 的GPU是Intel Xeon Phi 系列，属于计算卡，主要产品有Phi 5110P 、Phi 3210P、Phi 7120P、Phi 31S1P。</p><p>AMD 的GPU是图形和计算合一，主要产品有W5000、W9100、S7000、S9000、S10000。</p><p>1、公有云（PublicClouds），“公有”反映了这类云服务并非用户所拥有，公有云是面向大众提供计算资源的服务。是由IDC服务商或第三方提供资源，如应用和存储，这些资源是在服务商的场所内部署。用户通过Internet互联网来获取这些资源的使用。公有云服务提供商有Amazon、Google和微软，以及国内的阿里云、腾讯云等。</p><p> 公有云的优势是成本低，扩展性非常好。缺点是对于云端的资源缺乏控制、保密数据的安全性、网络性能和匹配性问题。</p><p>2、私有云（PrivateClouds），私有云是企业传统数据中心的延伸和优化，能够针对各种功能提供存储容量和处理能力。“私有”更多是指此类平台属于非共享资源，而非指其安全优势。私有云是为了一个客户单独使用而构建的，所以这些数据、安全和服务质量都较公有云有着更好地保障。而私有云由于是客户独享，则用户拥有着构建云的基础设置，并可以控制在此技术设置上部署应有程序的方式。</p><p>在私有云模式中，云平台的资源为包含多个用户的单一组织专用。私有云可由该组织、第三方或两者联合拥有、管理和运营。私有云的部署场所可以是在机构内部，也可以在外部。</p><p>私有云又分为两种</p><p>内部（on-premise）私有云：也被称为内部云，由组织在自己的数据中心内构建，如下图所示。该形式在规模和资源可扩展性上有局限，但是却有利于标准化云服务管理流程和安全性。组织依然要为物理资源承担资金成本和维护成本。这种方式适合那些需要对应用、平台配置和安全机制完全控制的机构。</p><p>外部（off-premise）私有云：这种私有云部署在组织外部，由第三方机构负责管理。第三方为该组织提供专用的云环境，并保证隐私和机密性。该方案相对内部私有云成本更低，也更便于扩展业务规模。</p><p>3、混合云（hybrid cloud）在混合云模式中，云平台由两种不同模式（私有或公有）云平台组合而成。这些平台依然是独立实体，但是利用标准化或专有技术实现绑定，彼此之间能够进行数据和应用的移植（例如，在不同云平台之间的均衡）。</p><p>应用混合云模式，一个机构可以将次要的应用和数据部署到公有云上，充分利用公有云在扩展性和成本上的优势。同时将任务关键型应用和数据放在私有云中，安全性更高。</p><p>区别1：从云的建设地点划分，公有云——互联网上发布的云计算服务，搭建云的资源在提供商的场所内；私有云——企业内部（专网）发布的云服务，搭建云平台所需的资源由企业自给。</p><p>区别2：从云服务的协议开发程度划分，公有云——协议开放的云计算服务，不需要专有的客户端软件解析。所有应用都是以服务的形式提供给用户的，而不是以软件包的形式提供。私有云——比如微软的“云端（云+端）”，最终用户需要有专用的软件。</p><p>区别3：从服务对象划分，私有云——为“一个”客户单独使用而构建的，因而提供对数据、安全性和服务质量的最有效控制；该公司拥有基础设施，并可以控制在此基础设施上部署应用程序的方式；私有云可部署在企业数据中心的防火墙内，也可以将它们部署在一个安全的主机托管场所；私有云可由云提供商进行构建，通过托管模式，构筑一个公司企业数据中心内的专用云。而公有云——则是针对外部客户，通过网络方式提供可扩展的弹性服务。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 分布式计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>添加Gitalk评论插件</title>
      <link href="2020/093038727.html"/>
      <url>2020/093038727.html</url>
      
        <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Gitalk-评论插件"><a href="#Gitalk-评论插件" class="headerlink" title="Gitalk 评论插件"></a>Gitalk 评论插件</h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Gitalk 是一个利用 Github API,基于 Github issue 和 Preact 开发的评论插件，在 Gitalk 之前还有一个 <a href="https://github.com/imsun/gitment">gitment</a> 插件也是基于这个原理开发的,不过 gitment 已经很久没人维护了。</p><h3 id="集成-Gitalk"><a href="#集成-Gitalk" class="headerlink" title="集成 Gitalk"></a>集成 Gitalk</h3><p>需要配置下面几个参数：</p><pre class=" language-js"><code class="language-js">clientID<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`Github Application clientID`</span></span><span class="token punctuation">,</span>clientSecret<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`Github Application clientSecret`</span></span><span class="token punctuation">,</span>repo<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`Github 仓库名`</span></span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//存储你评论 issue 的 Github 仓库名（建议直接用 GitHub Page 的仓库名）</span>owner<span class="token punctuation">:</span> <span class="token string">'Github 用户名'</span><span class="token punctuation">,</span>admin<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'Github 用户名'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//这个仓库的管理员，可以有多个，用数组表示，一般写自己,</span>id<span class="token punctuation">:</span> <span class="token string">'window.location.pathname'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//页面的唯一标识，gitalk 会根据这个标识自动创建的issue的标签,我们使用页面的相对路径作为标识</span></code></pre><p>当然，还有其他很多参数，有兴趣的话可以 <a href="https://github.com/gitalk/gitalk#options"> 点这里</a>。</p><p>比如我就增加了这个全屏遮罩的参数。</p><pre><code>distractionFreeMode: true,</code></pre><h3 id="创建-Github-Application"><a href="#创建-Github-Application" class="headerlink" title="创建 Github Application"></a>创建 Github Application</h3><p>Gitalk 需要一个 <strong>Github Application</strong>，<a href="https://github.com/settings/applications/new">点击这里申请</a>。</p><p>填写下面参数：</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fmm7jaib6fj30jo0gaacs.jpg"></p><p>点击创建</p><p>获取 <code>Client ID</code> 和 <code>Client Secret</code> 填入你的我们 Gitalk 参数中</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fmm7jrzff6j30lc0budhp.jpg"></p><p>当你参数都设置好，将代码推送到 Github 仓库后，没什么问题的话，当你点击进入你的博客页面后就会出现评论框了。</p><p>当你用 github 帐号登录（管理员），并且第一次加载该会比较慢，因为第一次加载会自动在你 <code>repo</code> 的仓库下创建对应 issue。</p><p>比如说这样：</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmm867n88cj30l809mjse.jpg"></p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmm8a0i0jkj30rr0ct42t.jpg"></p><h3 id="可能遇到的坑"><a href="#可能遇到的坑" class="headerlink" title="可能遇到的坑"></a>可能遇到的坑</h3><p>1、在配置好Gitalk后页面会出现</p><p><img src="https://img.gorpeln.com/blog_gittalk_003.jpeg" alt="blog_gittalk_003"></p><p>Gitalk在使用时要为每篇博文都进行一次初始化，就是需要管理员（你创建Gitalk的GitHub账号）登录一下。PS：我的GitHub账号一直处于登录状态，发布文章后，我在预览的过程就实现了初始化，感觉影响不大。</p><p>如果你实在忍不了，可以看一下大佬实现的<a href="https://draveness.me/git-comments-initialize">自动初始化</a>。</p><p>2、评论初始化404</p><p>出现这种错误是因为：</p><p>issue的标签label有长度限制！labels的最大长度限制是50个字符</p><p>在生成label的时候 id:window.location.pathname</p><p>可能会根据编码不同而导致实际id超出50个字符，就会报错404</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 评论插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux系统下升级cmake版本</title>
      <link href="2020/093056989.html"/>
      <url>2020/093056989.html</url>
      
        <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="1-问题出现"><a href="#1-问题出现" class="headerlink" title="1.问题出现"></a>1.问题出现</h3><pre><code>cmake版本太低，无法支持某些操作</code></pre><h3 id="2-查看对应的cmake版本"><a href="#2-查看对应的cmake版本" class="headerlink" title="2.查看对应的cmake版本"></a>2.查看对应的cmake版本</h3><pre><code>cmake --version</code></pre><h3 id="3-卸载过去旧的版本"><a href="#3-卸载过去旧的版本" class="headerlink" title="3.卸载过去旧的版本"></a>3.卸载过去旧的版本</h3><pre><code>sudo apt-get autoremove cmake</code></pre><h3 id="4-下载新的版本"><a href="#4-下载新的版本" class="headerlink" title="4.下载新的版本"></a>4.下载新的版本</h3><pre><code>cd ~wget https://cmake.org/files/v3.13/cmake-3.13.2.tar.gztar xvf cmake-3.13.2.tar.gzcd cmake-3.13.2</code></pre><h3 id="5-安装"><a href="#5-安装" class="headerlink" title="5.安装"></a>5.安装</h3><pre><code>./bootstrap --prefix=/usr make sudo make install</code></pre><h3 id="6-查看新的版本"><a href="#6-查看新的版本" class="headerlink" title="6.查看新的版本"></a>6.查看新的版本</h3><pre><code>cmake --version</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/092916107.html"/>
      <url>2020/092916107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
